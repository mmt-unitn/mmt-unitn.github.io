[
  {
    "objectID": "fft.html",
    "href": "fft.html",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "",
    "text": "Nella scienza delle misure stanno esplodendo due settori apparentemente non collegati: sensori al silicio, derivanti dalle tecnologie consolidate dei micro-chip, stanno soppiantando i tradizionali sensori (nonostante questi ultimi possiedano qualità metrologiche nettamente superiori); nuovi strumenti di elaborazione dati (PC, DSP, processori, micro-controllori, etc), sempre più potenti ed economici, stanno promuovendo l’impiego di algoritmi sempre più complessi (reti neurali, fuzzy sets, wavelets, etc). Si pensi ai moderni smartphone che contengono diversi sensori (una IMU, Inertial Measurement Unit che contiene accelerometri e giroscopi per la misura del moto, videocamere ed in alcuni casi anche telecamere a tempo di volo per la misura in 3 dimensioni) ed un processore estremamente potente a bordo.\nI due aspetti, oltre che essere legati allo stesso fenomeno tecnologico, sono concorrenti nello stimolare il seguente approccio: utilizzare sensori di bassa qualità accoppiati a sistemi di acquisizione ed elaborazione complessa dei dati. In altre parole, le necessità di mercato stanno spingendo verso la ricerca di sensori che sfruttino le tecnologie consolidate della lavorazione del silicio che forniscono il duplice vantaggio della produzione in larga scala e quindi basso costo e quello della estrema miniaturizzazione ed integrazione con l’elettronica di condizionamento ed elaborazione segnali che consentono di impiegare algoritmi avanzati capaci di ottenere un’accuratezza adeguata anche da misure effettuate tramite sensori di bassa qualità. Si potrebbe citare la tecnologia dei sistemi embedded che, in maniera pervasiva, occupa gli spazi di vita quotidiana (con reti di sistemi di sorveglianza, sensori distribuiti per la domotica, etc) o industriale (reti di sensori per l’ottimizzazione della produzione e la diagnostica del processo produttivo giusto per citare alcuni esempi).\nSi potrebbe aggiungere l’enorme sviluppo dell’intelligenza artificiale che si basa sulla raccolta dati, ovvero segnali generalmente variabili nel tempo. Non da ultimo è da considerare che per le applicazioni in ambito ingegneria meccatronica si ha a che fare con sistemi autonomi di cui si vuole controllare un certo numero di stati. A tale scopo è fondamentale la misura di tali stati che, se incogniti, ovviamente non sarebbero controllabili. Ebbene in ambito automatico gli stati sono associati a parametri di misura tempovarianti da cui occorre estrapolare delle informazioni tramite elaborazione di segnali tempovarianti.\nIn altre parole, l’elaborazione dei segnali acquisiti tramite reti di sensori distribuiti o da un sistema robotico, richiedono ad un ingegnere meccatronico la capacità di elaborarli. Questo per diversi scopi quali sintetizzare una variabile da controllare, ottenere informazioni legate alla diagnostica delle macchine o semplicemente per ridurre il rumore sovrapposto al segnale.\nL’obiettivo di questa dispensa è quello di fornire i rudimenti essenziali per il “signal processing” che comprendono l’elaborazione nel dominio della frequenza tramite Trasformata di Fourier, il concetto e la stima tramite Taratura Dinamica della Funzione di Trasferimento, la Modellazione a Parametri Concentrati dei sistemi meccanici e conseguente estrapolazione delle Impedenze Generalizzate che consentono di costruire reti analoghe a quelle elettriche per la stima delle relazioni dinamiche che intervengono nei diversi punti del meccanismo."
  },
  {
    "objectID": "fft.html#segnali-tempovarianti-segnali-discreti-vettori",
    "href": "fft.html#segnali-tempovarianti-segnali-discreti-vettori",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.1 Segnali tempovarianti, segnali discreti, vettori",
    "text": "2.1 Segnali tempovarianti, segnali discreti, vettori\nUn segnale funzione del tempo s(t) rappresenta un segnale reale che varia in funzione del tempo senza soluzione di continuità. Un segnale discreto è un segnale campionato e quantizzato. Dunque rappresentabile tramite un vettore s = \\{s(1), s(2), \\dots, S(N)\\}, dove n = 1\\dots N sono gli N campioni acquisiti ad una certa frequenza di campionamento f_c.\nCome vedremo quindi vi sarà una differenza tra la Trasformata di Fourier di un segnale tempovariante da quella di un segnale discreto. La prima ha un carattere ed una utilità simbolica, potremmo dire di concetto. La seconda pratica poiché tutti i segnali che si elaborano mediante processori sono discreti.\nNei prossimi sotto-paragrafi passeremo:\n\ndalla scomposizione di un vettore su di una base di versori ortonormali\nalla scomposizione di un segnale tempovariante periodico su una base di segnali ortonormali\nalla scomposizione di un segnale tempovariante non periodico su una base di segnali ortonormali\nalla scomposizione di un segnale discreto (ovvero un vettore) su una base di segnali discreti ortonormali (altri vettori).\n\nTutto ciò per comprendere cosa rappresentano le componenti del segnale nel dominio della frequenza (sia esso continuo o discreto) e, tramite il concetto di Funzione di Trasferimento, implementare le elaborazioni che si possono condurre in tale dominio. Tutto ciò consentirà di capire come gli strumenti di misura di grandezze tempovarianti si comportano con il misurando in base alle caratteristiche dinamiche riassunte proprio dalla loro funzione di trasferimento."
  },
  {
    "objectID": "fft.html#scomposizione-di-un-vettore-su-di-una-base-di-versori-orto-normali",
    "href": "fft.html#scomposizione-di-un-vettore-su-di-una-base-di-versori-orto-normali",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.2 Scomposizione di un vettore su di una base di versori orto-normali",
    "text": "2.2 Scomposizione di un vettore su di una base di versori orto-normali\nPer comprendere il concetto di scomposizione di un segnale tempovariante si può pensare al parallelo vettoriale: un vettore nel piano può essere scomposto secondo due direzioni mutuamente ortogonali. In tale maniera si ottiene la scomposizione mediante la semplice relazione del prodotto scalare :\n\n\\mathbf{v} = \\alpha \\mathbf{e}_1 + \\beta \\mathbf{e}_2\n\\tag{1}\ndove \\mathbf{e}_1 ed \\mathbf{e}_2 sono i versori delle direzioni mutuamente ortogonali (\\mathbf{e}_1 \\cdot \\mathbf{e}_2 = 0). Grazie alla proprietà di ortogonalità della base posso scrivere infatti:\n\n\\alpha = \\mathbf{v}\\cdot\\mathbf{e}_1 =  (\\alpha \\mathbf{e}_1 + \\beta \\mathbf{e}_2)\\cdot \\mathbf{e}_1 \\\\\n\\beta = \\mathbf{v}\\cdot\\mathbf{e}_2\n\\tag{2}\nche definisce l’operazione di scomposizione tramite la semplice operazione di prodotto scalare. L’Equazione 1 suggerisce di rappresentare il vettore in una maniera diversa, ovvero considerando le sole componenti lungo i due versori:\n\n\\mathbf{v}=[\\alpha, \\beta]\n\ntale rappresentazione consente di effettuare considerazioni sul vettore solamente tramite le sue componenti nelle direzioni della base ortogonale di vettori \\mathbf{e}_1 ed \\mathbf{e}_2. Ovvero il vettore può essere ‘pensato’ come una ‘freccia’ nel piano oppure come insieme di componenti. Tale concetto è illustrato nella figura seguente.\n\n\n\n\n\n\nFigura 1: Corrispondenza tra un vettore nel piano e l’insieme delle sue componenti lungo una coppia di versori ortogonali\n\n\n\nLa relazione di eguaglianza espressa in Equazione 1 garantisce la reversibilità, ovvero dati i parametri della trasformazione in componenti vettoriali lungo una coppia di direzioni ortogonali, è possibile risalire esattamente al vettore originario. Vedremo che non tutte le trasformazioni sono reversibili e che la reversibilità garantisce una corretta interpretazione delle operazioni effettuate nel dominio della trasformata. Introducendo ad esempio il concetto di filtro sulle componenti vettoriali come quell’operatore che fornisce la sola componente lungo \\mathbf{e}_1 , si ottiene il valore del coefficiente \\alpha che si sa essere esattamente corrispondente al vettore tolta la componente lungo l’altra direzione. Questa sembrerebbe una tautologia, ma, applicata alle trasformazioni di segnale, giustifica e fornisce la corretta interpretazione alle operazioni di manipolazione in frequenza quali il filtraggio: in una comune operazione di filtraggio passa-basso si ha la certezza di aver eliminato le componenti armoniche del segnale ad alta frequenza e di aver lasciato inalterate le rimanenti.\nDalla Equazione 1 e la Equazione 2 si ottiene:\n\n\\mathbf{v} = (\\mathbf{v}\\cdot\\mathbf{e}_1) \\mathbf{e}_1 + (\\mathbf{v}\\cdot \\mathbf{e}_2) \\mathbf{e}_2\n\nche riassume i concetti prima espressi."
  },
  {
    "objectID": "fft.html#scomposizione-di-un-segnale-tempovariante-continuo-su-di-una-base-di-funzioni-orto-normali",
    "href": "fft.html#scomposizione-di-un-segnale-tempovariante-continuo-su-di-una-base-di-funzioni-orto-normali",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.3 Scomposizione di un segnale tempovariante continuo su di una base di funzioni orto-normali",
    "text": "2.3 Scomposizione di un segnale tempovariante continuo su di una base di funzioni orto-normali\nPer i segnali temporali vale un ragionamento analogo. Per semplicità considereremo lo sviluppo in serie invece della trasformata di Fourier in quanto da esso è poi possibile, tramite passaggio al limite, ricavare la formula della trasformata 1.\nUna funzione periodica gode della proprietà che g(t)=g(t+nT) per ogni valore n intero. T è il periodo ed f_0 = 1/T è la frequenza fondamentale, mentre \\omega = 2\\pi f è la pulsazione. Essa può essere scomposta in serie di Fourier come segue.\nAvendo un segnale s(t), rappresentabile nel dominio del tempo, si può definire lo sviluppo di Fourier tramite la relazione invertibile:\n\ng(t)=\\frac{1}{2}a_o + \\sum_{n=1}^{\\infty}a_n \\cos(\\omega_n t) + \\sum_{n=1}^{\\infty}b_n \\sin(\\omega_n t)\n\\tag{3}\nDove \\omega_n = 2\\pi n f_0.\nI coefficienti a_n e b_n vengono ricavati secondo le seguenti relazioni:\n\na_n = \\frac{2}{T}\\int_0^T g(\\tau)\\cos(\\omega_nt)d\\tau \\\\\nb_n = \\frac{2}{T}\\int_0^T g(\\tau)\\sin(\\omega_nt)d\\tau\n\\tag{4}\nLa Equazione 3 vuol dire scomporre la funzione g(t) secondo la base di funzioni ortogonali armoniche.\nNOTA: la Equazione 3 corrisponde anche alla media delle componenti del prodotto elemento per elemento tra i due vettori."
  },
  {
    "objectID": "fft.html#definizione-di-prodotto-scalare-tra-funzioni-continue-e-discrete",
    "href": "fft.html#definizione-di-prodotto-scalare-tra-funzioni-continue-e-discrete",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.4 Definizione di prodotto scalare tra funzioni continue e discrete",
    "text": "2.4 Definizione di prodotto scalare tra funzioni continue e discrete\nIl prodotto scalare tra segnali/funzioni periodiche si definisce come:\n\ng(t)\\bullet f(t)=\\frac{1}{T}\\int_0^T g(\\tau)f^*(\\tau)d\\tau\n\\tag{5}\ndove con f^*(t) si intende la funzione complessa coniugata di f(t) che, nel caso di funzioni reali, coincide con se stessa.\nLe stesse funzioni digitalizzate g_k ed f_k consistono nei due vettori \\{g(1), g(2),\\dots, g(N)\\} e \\{f(1), f(2),\\dots, f(N)\\} e quindi si definisce prodotto scalare tra i segnali digitalizzati:\n\ng_k\\bullet f_k=\\frac{1}{T}\\sum_{i=1}^N g_i f_i = \\\\\n\\{g(1), g(2),\\dots, g(N)\\} \\bullet \\{f(1), f(2),\\dots, f(N)\\}^T / N\n\\tag{6}\nDi seguito un esempio in R di scomposizione di un’onda quadra su una base ortogonale e sua ricomposizione sulla stessa base. Poi scomposizione e ricomposizione secondo la serie di Fourier. Si noti che un’onda quadra che parte con fronte di salita esattamente con il primo campione risulta essere scomponibile solo mediante sinusoidi per cui dimenticheremo le componenti coseno."
  },
  {
    "objectID": "fft.html#esempio",
    "href": "fft.html#esempio",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.5 Esempio",
    "text": "2.5 Esempio\nDefiniamo le funzioni prodotto scalare tra segnali digitalizzati e relativa norma. La prima funzione la definiamo come operatore %ps%:\n\n  # secondo le equazioni:\n`%ps%` &lt;- function(A, B) {\n  (t(A) %*% B / length(A)) %&gt;% as.numeric()\n}\n\n# ma anche, più efficientemente:\n`%ps%` &lt;- function(A, B) mean(A*B)\n\nPer la norma, definiamo la funzione norm_ps (dato che norm è già definita):\n\nnorm_ps &lt;- function(A) sqrt(A %ps% A)\n\n(1:5) %ps% (5:1)\n\n[1] 7\n\nnorm_ps(1:5)\n\n[1] 3.316625\n\n\nOra creiamo un segnale onda quadra (il segno dell’onda seno) campionato su 1000 punti tra 0 e 1, con frequenza 2 Hz:\n\nf0 &lt;- 2\nfc &lt;- 1000\nTm &lt;- 1\ndt &lt;- 1/fc\n\nsin_k &lt;- function(x, f, k=1) sin(2*pi*f*k*x)\n\ndf &lt;- tibble(\n  t = seq(dt, Tm, dt),\n  ys = sin_k(t, f0),\n  yq = sign(ys)\n)\n\ndf %&gt;% \n  pivot_longer(-t, names_to = \"signal\") %&gt;% \n  ggplot(aes(x=t, y=value, color=signal)) +\n  geom_line() \n\n\n\n\nOnda quadra e corrispondente sinusoide di pari frequenza e ampiezza\n\n\n\n\nCalcoliamo le prime sette componenti della serie, secondo Equazione 6:\n\nK &lt;- 7\ncomps &lt;- map_dbl(1:K, \\(k) {\n  s &lt;- sin_k(df$t, f0, k)\n  df$yq %ps% s/norm_ps(s)\n}) %&gt;% zapsmall()\n\ncomps\n\n[1] 0.9003045 0.0000000 0.3000699 0.0000000 0.1800040 0.0000000 0.1285337\n\n\nInfine approssimiamo l’onda quadra come somma delle prime 7 componenti:\n\ndf %&gt;% \n  mutate(\n    yqk = reduce(1:K, \\(acc, k) {\n      s &lt;- sin_k(t, f0, k)\n      acc + comps[k] * s / norm_ps(s)\n    }, .init=0)\n  ) %&gt;% \n  pivot_longer(-t, names_to = \"signal\") %&gt;% \n  ggplot(aes(x=t, y=value, color=signal)) +\n  geom_line()\n\n\n\n\nOnda quadra e sua approssimazione come composizione dei primi sette termini della serie di Fourier\n\n\n\n\n\n\n\n\n\n\nEsercizi\n\n\n\n\nPartire da K=1 e incrementare di 1 alla volta. Cosa si nota?\nCon f_0=1 aumentare K di alcune centinaia e poi vicino a 500. Cosa succede? Esiste un numero K per cui il segnale ricomposto diviene pressoché perfettamente un’onda quadra?\nMostrare in un grafico i coefficienti in funzione della frequenza.\nCon f_0 = 4; aumentate K fino ad ottenere un’onda quadra perfettamente ricomposta. Quanto vale K? C’è qualche nesso con il teorema di Nyquist?\nAumentate ancora K, cosa succede? C’è, di nuovo, qualche nesso con il teorema di Nyquist? Che effetto sta subendo il segnale ricostruito?\n\n\n\nDall’esempio qui sopra in cui, per semplicità, ci siamo occupati di un caso in cui sono presenti solo componenti seno abbiamo compreso che lo sviluppo in serie di Fourier di un segnale tempovariante è dato dalla sommatoria pesata di componenti armoniche. Tali armoniche rappresentano una base di funzioni ortogonali ma non ortonormali.\nSi ha infatti:\n\n\\begin{aligned}\n\\sin(\\omega_nt) \\bullet  \\sin(\\omega_nt) &= \\frac{1}{T}\\int_0^T \\sin^2(\\omega_nt)~dt = \\frac{1}{T}\\int_0^T\\frac{1-2\\cos(2\\omega_nt)}{2}=\\frac{1}{2} \\\\\n\\cos(\\omega_nt) \\bullet  \\cos(\\omega_nt) &= \\frac{1}{T}\\int_0^T \\cos^2(\\omega_nt)~dt = \\frac{1}{T}\\int_0^T\\frac{1+2\\cos(2\\omega_nt)}{2}=\\frac{1}{2} \\\\\n\\cos(\\omega_nt) \\bullet  \\sin(\\omega_nt) &= \\frac{1}{T}\\int_0^T \\sin(\\omega_nt)\\cos(\\omega_nt)~dt = \\frac{1}{T}\\int_0^T\\frac{\\sin(2\\omega_nt)}{2}=0 \\\\\n\\cos(\\omega_nt) \\bullet  \\cos(\\omega_kt) &= \\frac{1}{T}\\int_0^T \\frac{\\cos(\\omega_nt+\\omega_kt)\\cos(\\omega_nt-\\omega_kt)}{2}~dt = 0,\\quad n\\neq k \\\\\n\\sin(\\omega_nt) \\bullet \\sin(\\omega_kt) &= \\dots = 0 \\\\\n\\sin(\\omega_nt) \\bullet \\cos(\\omega_kt) &= \\dots = 0\n\\end{aligned}\n\\tag{7}\nPer ottenere una scomposizione corretta occorre introdurre al denominatore dei coefficienti il quadrato del modulo (delle componenti la base di funzioni) quindi 1/2 che, portato a numeratore, spiega il fattore 2 nelle Equazione 4.\n\n\n\n\n\n\nFigura 2: Corrispondenza tra una funzione del tempo e l’insieme delle sue componenti secondo una base di funzioni ortonormali\n\n\n\nPassiamo ora a come rappresentare le funzioni in maniera analoga a quanto facciamo con i vettori. La Equazione 3 suggerisce infatti la rappresentazione di Figura 2, analoga a quella riportata in Figura 1.\nSecondo quanto rappresentato in Figura 2 si potrebbe ragionare indifferentemente (grazie alla relazione di eguaglianza in Equazione 3 sulla funzione del tempo oppure su due funzioni (discrete) che rappresentano le componenti della scomposizione secondo Fourier.\nEsiste però una rappresentazione più significativa sia per l’analisi segnali che per la soluzione di equazioni differenziali associate a sistemi lineari. Per determinare tale rappresentazione è necessario elaborare la Equazione 3 impiegando la formula di Eulero, ovvero i fasori:\n\ne^{i\\omega_nt} = \\cos(\\omega_nt) + i\\sin(\\omega_nt)\n\nche porta ad esprimere le funzioni armoniche seno e coseno come:\n\n\\begin{aligned}\n\\cos(\\omega_nt)&=\\frac{e^{i\\omega_nt}+e^{-i\\omega_nt}}{2} \\\\\n\\sin(\\omega_nt)&=\\frac{e^{i\\omega_nt}-e^{-i\\omega_nt}}{2i} \\\\\n\\end{aligned}\n le quali, sostituite nella Equazione 3, comportano:\n\n\\begin{aligned}\ng(t) &= \\frac{1}{2}a_o + \\sum_{n=1}^\\infty a_n\\frac{e^{i\\omega_nt}+e^{-i\\omega_nt}}{2} + \\sum_{n=1}^\\infty b_n\\frac{e^{i\\omega_nt}-e^{-i\\omega_nt}}{2i} \\\\\ng(t) &= \\frac{1}{2}a_o + \\frac{1}{2}\\sum_{n=1}^\\infty (a_n-ib)e^{i\\omega_nt}    + \\sum_{n=1}^\\infty (a_n+ib)e^{-i\\omega_nt}\n\\end{aligned}\n dalla quale, ponendo: \nG_0 = a_0/2 \\\\\nG_n = (a_n-ib)/2 \\\\\nG_{-n} = (a_n + ib_n)/2 = G^*\n\\tag{8} si può scrivere: \ng(t)=G_0 + \\sum_{n=1}^{\\infty}G_n e^{i\\omega_nt} + \\sum_{n=-1}^{-\\infty}G_n e^{i\\omega_nt}\n cioè: \ng(t) = \\sum_{n=-\\infty}^{\\infty}G_n e^{i\\omega_nt}\n\\tag{9}\nLe componenti, ovvero quanto ognuna di tali funzioni pesa nella ricostruzione della funzione g(t) del tempo, si ricava in maniera analoga: \nG_n = g(t) \\bullet e^{i\\omega_nt}=\\frac{1}{T}\\int_0^T g(\\tau)\\left(e^{i\\omega_n\\tau}\\right)^*~d\\tau = \\frac{1}{T}\\int_0^Tg(\\tau)e^{-i\\omega_n\\tau}~d\\tau\n\\tag{10}\nTale rappresentazione complessa, anche definita spettro del segnale, ha il vantaggio di consentire un’immediata valutazione della risposta di un sistema regolato da equazioni differenziali lineari conoscendo le componenti G_n del segnale in ingresso. La dimostrazione di ciò verrà riportata tra breve nel paragrafo “Funzione di Trasferimento sinusoidale”.\nIn questo caso la base di funzioni è sia ortogonale come nel caso delle armoniche pure, ma anche normale: \ne^{i\\omega_nt}\\bullet e^{i\\omega_kt} = \\frac{1}{T}\\int_0^T e^{i\\omega_n\\tau}\\left(e^{i\\omega_k\\tau}\\right)^*~d\\tau=\\delta_{n,k}\n dove \\delta_{n,k} è il delta di Kroneker. Nel caso in cui n = k basta seguire i seguenti passaggi: \n\\begin{aligned}\ne^{i\\omega_nt}\\bullet e^{i\\omega_kt} &= \\frac{1}{T}\\int_0^T e^{i\\omega_n\\tau}\\left(e^{i\\omega_k\\tau}\\right)^*~d\\tau \\\\\n&= \\frac{1}{T}\\int_0^T (\\cos(\\omega_n\\tau) + i\\sin(\\omega_n\\tau))~(\\cos(\\omega_n\\tau)-i\\sin(\\omega_n\\tau))~d\\tau \\\\\n&= \\frac{1}{T}\\int_0^T \\cos^2(\\omega_n\\tau)~d\\tau + \\frac{1}{T}\\int_0^T \\sin^2(\\omega_n\\tau)~d\\tau = \\frac{1}{2} + \\frac{1}{2} \\\\\n&= 1\n\\end{aligned}\n\nNel caso in cui n\\neq k la dimostrazione è banale se si considera l’ortogonalità delle funzioni armoniche.\nÈ opportuno anche notare come le componenti G_{-n} e G_n danno vita a segnali armonici reali. Si nota infatti che:\n\nG_n~e^{i\\omega_nt} + G_{-n}~e^{-i\\omega_nt} = G_n~e^{i\\omega_nt} + G_n^*~(e^{i\\omega_nt})^* = G_n~e^{i\\omega_nt} + (G_n~e^{i\\omega_nt})^*\n che, andando a comporre graficamente i due fasori, fornisce la seguente rappresentazione ed il segnale corrispondente s_n(t) = 2M_n\\cos(\\omega t+\\phi_n)\n\n\n\n\n\n\n\n\nFasore e suo coniugato a base della scomposizione\n\n\n\n\n\n\n\nCoefficiente dello sviluppo in serie di Fourier e suo coniugato\n\n\n\n\n\n\nFigura 3\n\n\n\n\n\n\n\n\n\n\n\nComposizione grafica dei due fasori (a)\n\n\n\n\n\n\n\nComposizione grafica dei due fasori (b)\n\n\n\n\n\n\nFigura 4\n\n\n\nLa differenza tra l’espressione dell’equazione Equazione 3 e quella della Equazione 9 è che nel primo caso si tratta di coefficienti a_n e b_n reali, nel secondo di coefficienti complessi di cui, come è schematizzato in Figura 5, è possibile rappresentare le due funzioni modulo e fase in funzione della frequenza. Tali moduli e fasi, è facile convincersene tenendo conto dei passaggi che hanno condotto dalla Equazione 3 alla Equazione 11 e la rappresentazione dei fasori appena riportata, sono proprio i moduli e le fasi delle componenti armoniche che compongono il segnale s(t).\n\n\n\n\n\n\nFigura 5: Corrispondenza tra un segnale periodico e l’insieme delle componenti secondo una base di funzioni complesse ortonormali oppure con due funzioni discrete che rappresentano l’andamento dell’insieme dei coefficienti in modulo e fase.\n\n\n\nRappresentiamo di nuovo i segnali in maniera analoga a quanto facciamo con i vettori. La Equazione 10 suggerisce ora la rappresentazione di Figura 5, analoga a quella riportate in figure Figura 2 e Figura 1.\nLa proprietà della reversibilità, valida per l’eguaglianza espressa nella Equazione 3, permette di effettuare operazioni di manipolazione in frequenza, quindi di antitrasformare tornando nel dominio del tempo avendo la certezza di non aver introdotto ulteriori elaborazioni a causa della doppia trasformazione. Un classico esempio è l’operazione di filtraggio passa-basso su segnali aventi una componente additiva di rumore in alta frequenza. In tale caso l’operazione di filtraggio passa-basso assicura l’eliminazione delle sole componenti in alta frequenza ipotizzate appartenenti al rumore.\nFunzioni non periodiche possono essere immaginate come funzioni periodiche dal periodo T \\rightarrow \\infty e quindi la frequenza fondamentale f_0 \\rightarrow 0. Le scomposizioni di Equazione 9 e Equazione 10 assumono la forma definita come Trasformata di Fourier:\n\n\\begin{aligned}\ng(t) &= \\frac{1}{2\\pi}\\int_{-\\infty}^\\infty G(\\omega)~e^{i\\omega t}~d\\omega \\\\\nG(\\omega) &= \\int_{-\\infty}^\\infty g(t)~e^{-i\\omega t}~dt\n\\end{aligned}\n\\tag{11} notare la convenzione impiegata per indicare la trasformata di una funzione g(t) con la lettera maiuscola, ovvero come G(\\omega).\nDi seguito la dimostrazione delle Equazione 11:\nSe definiamo:\n\nA_n := T \\bullet G_n = \\int_0^Tg(t)~e^{-i\\omega_nt}~dt\n questo corrispondere semplicemente a modificare la definizione di prodotto scalare tra funzioni del tempo, che da \nf(t)\\bullet g(t) = \\frac{1}{T}\\int_0^Tf(t)~g(t)^*~dt\n diventa: \nf(t)\\bullet g(t) = \\int_0^Tf(t)~g(t)^*~dt\n\nQuesto serve in quanto, dovendo tendere T\\rightarrow\\infty, si avrebbe uno 0 che moltiplica l’integrale. Questo viene quindi eliminato dalla definizione.\nOra facciamo tendere T\\rightarrow\\infty: si ottiene: \nA_{f=\\frac{n}{T}} = A(\\omega_n) = \\int_{-\\infty}^\\infty g(t)~e^{-i\\omega_nt}~dt\n Questa corrisponde alla seconda delle Equazione 11. In particolare, i coefficienti discreti A_n diventano una funzione continua della frequenza (o pulsazione) in quanto il passo tra frequenze successive diviene infinitesimo. Dunque, le funzioni che rappresentano le componenti della scomposizione (analoghe a quelle rappresentate in Figura 5) non saranno più funzioni discrete, bensì continue in quanto l’intervallo di spaziatura sulle ascisse (nel dominio della pulsazione) pari a 2\\pi/T tende a zero.\nConsideriamo ora la Equazione 9:\n\ng(t) = \\sum_{n=-\\infty}^\\infty G_n~e^{i\\omega_nt} = \\sum_{n=-\\infty}^\\infty \\frac{A_n}{T}~e^{i\\omega_nt} = \\frac{1}{T} \\sum_{n=-\\infty}^\\infty A~e^{i\\omega_nt}\n se facciamo tendere T\\rightarrow\\infty, A_n diviene una funzione continua della pulsazione A(\\omega) per cui la sommatoria diviene un integrale ottenendo: \n\\int_{-\\infty}^\\infty A(\\omega)~e^{i\\omega t}~df = \\int_{-\\infty}^\\infty A(\\omega)~e^{i\\omega t}\\frac{2\\pi}{2\\pi}~df = \\frac{1}{2\\pi}\\int_{-\\infty}^\\infty A(\\omega)~e^{i\\omega t}~d\\omega\n Che corrisponde alla prima delle Equazione 11.\n\n\n\nCorrispondenza tra un segnale non periodico e l’insieme delle sue componenti secondo una base di funzioni complesse ortonormali oppure con due funzioni continue che rappresentano l’andamento dell’insieme dei coefficienti in modulo e fase."
  },
  {
    "objectID": "fft.html#alcune-proprietà-della-trasformata-di-fourier",
    "href": "fft.html#alcune-proprietà-della-trasformata-di-fourier",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.6 Alcune proprietà della trasformata di Fourier",
    "text": "2.6 Alcune proprietà della trasformata di Fourier\nLa trasformata di Fourier gode delle proprietà elencate in Tabella 1.\n\n\n\nTabella 1: Proprietà della trasformata di Fourier\n\n\n\n\n\n\n\n\n\nProprietà\nRelazione nel dominio del tempo e dello spettro\n\n\n\n\nLinearità\na x(t) + b y(t)\\rightarrow a X(\\omega) + b Y(\\omega)\n\n\nDerivata\n\\dot x(t) \\rightarrow i\\omega X(\\omega)\n\n\nIntegrale\n\\int_0^t x(\\tau)~d\\tau \\rightarrow \\frac{1}{i\\omega}X(\\omega)\n\n\nVariazione scala\nx(at)\\rightarrow\\frac{1}{|a|}X(\\frac{\\omega}{a}\n\n\nAnticipo/Ritardo\nx(t-\\tau)\\rightarrow X(\\omega)~e^{-i\\omega\\tau}\n\n\nModulazione\nx(t)~e^{-i\\omega_0t}\\rightarrow X(\\omega-\\omega_0)\n\n\nConvoluzione\nx(t) \\otimes y(t)\\rightarrow X(\\omega)Y(\\omega)\n\n\nProdotto\nx(t)y(t)\\rightarrow X(\\omega)\\otimes Y(\\omega)"
  },
  {
    "objectID": "fft.html#dimostrazione-di-alcune-proprietà",
    "href": "fft.html#dimostrazione-di-alcune-proprietà",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.7 Dimostrazione di alcune proprietà",
    "text": "2.7 Dimostrazione di alcune proprietà\nDi seguito le dimostrazioni:\n\n2.7.1 Linearità\n\n\\begin{aligned}\n\\Im(a~x(t) + b~y(t)) &= \\int_{-\\infty}^\\infty \\left[a~x(t) + b~y(t)\\right]~e^{-i\\omega t}~dt \\\\\n&= \\int_{-\\infty}^\\infty a~x(t)~e^{-i\\omega t}~dt + \\int_{-\\infty}^\\infty b ~x(t)~e^{-i\\omega t}~dt \\\\\n&= a\\int_{-\\infty}^\\infty x(t)~e^{-i\\omega t}~dt + b\\int_{-\\infty}^\\infty~x(t)~e^{-i\\omega t}~dt \\\\\n&= a~X(\\omega) + b~Y(\\omega)\n\\end{aligned}\n\n\n\n2.7.2 Derivata\nDifferenziando la trasformata inversa di X(\\omega) rispetto al tempo (che equivale a derivare il segnale x(t)), si ottiene:\n\n\\begin{aligned}\n\\frac{d}{dt}x(t) &= \\frac{d}{dt}\\left\\{\\frac{1}{2\\pi}\\int_{-\\infty}^\\infty X(\\omega)~e^{i\\omega t}~d\\omega \\right\\} \\\\\n&= \\frac{1}{2\\pi} \\int_{-\\infty}^\\infty X(\\omega)~\\frac{d}{dt}\\left(e^{i\\omega t}\\right)~d\\omega \\\\\n&= \\frac{1}{2\\pi} \\int_{-\\infty}^\\infty \\left[i\\omega X(\\omega)\\right]~e^{i\\omega t}~d\\omega \\\\\n&= \\Im^{-1}\\left\\{i\\omega X(\\omega)\\right\\}\n\\end{aligned}\n\n\n\n2.7.3 Convoluzione\n\n\\begin{aligned}\nx(t) \\otimes y(t) &= \\int_{-\\infty}^\\infty x(\\tau)y(t-\\tau)~d\\tau \\\\\n\\Im\\left\\{x(t) \\otimes y(t)\\right\\} &= \\int_{-\\infty}^\\infty\\left[ \\int_{-\\infty}^\\infty x(\\tau)y(t-\\tau)~d\\tau \\right]~e^{-i\\omega t}~dt \\\\\n&= \\int_{-\\infty}^\\infty x(\\tau)\\left[ \\int_{-\\infty}^\\infty y(t-\\tau)~e^{-i\\omega t}~dt\\right]~d\\tau  \\\\\n&= \\int_{-\\infty}^\\infty x(\\tau)\\left[ \\int_{-\\infty}^\\infty y(\\xi)~e^{-i\\omega \\xi}~e^{-i\\omega \\tau}~d\\xi\\right]~d\\tau  \\\\\n&= \\int_{-\\infty}^\\infty x(\\tau)~e^{-i\\omega\\tau} \\left[ \\int_{-\\infty}^\\infty y(\\xi)~e^{-i\\omega \\xi}~d\\xi\\right]~d\\tau  \\\\\n&= X(\\omega)Y(\\omega)\n\\end{aligned}\n\nSi noti che si è sostituita la variabile t con t-\\tau nell’integrale ‘interno’ nella seguente maniera: \n\\begin{aligned}\n\\xi &= t - \\tau \\\\\nt &= \\xi + \\tau \\\\\nd\\xi &= dt\n\\end{aligned}\n\nGli estremi di integrazione, essendo da -\\infty a +\\infty rimangono invariati. Questa proprietà è connessa con la soluzione di equazioni differenziali lineari che nel dominio del tempo corrisponde ad una operazione di convoluzione, nel dominio della frequenza ad una semplice moltiplicazione di funzioni della frequenza.\n\n\n2.7.4 Ritardo/anticipo\n\n\\begin{aligned}\n\\Im\\left\\{x(t\\pm t_0)\\right\\} &= \\int_{-\\infty}^\\infty x(t\\pm t_0)~e^{-i\\omega t}~dt \\\\\n&= \\int_{-\\infty}^\\infty x(t')~e^{-i\\omega (t'\\mp t_0)}~dt' \\\\\n&= e^{\\pm i\\omega t_0} \\int_{-\\infty}^\\infty x(t')e^{-i\\omega t'}~dt' \\\\\n&= X(\\omega)~e^{\\pm i \\omega t_0}\n\\end{aligned}\n\nQuesta proprietà evidenzia come un ritardo/anticipo di un segnale nel tempo ha influenza solo sulla fase dello spettro mentre ne lascia invariato il modulo (il fattore esponenziale con argomento immaginario ha modulo unitario e fase pari all’argomento stesso). Intuitivamente questo è ovvio in quanto le componenti dello sviluppo in serie saranno identiche come ampiezza mentre saranno ritardate/anticipate di t_0. Considerando una singola componente dello sviluppo inserire ad esempio: \na_n\\cos(\\omega_n(t\\pm t_0)) = a_n\\cos(\\omega_n t \\pm \\omega_n t_0)\n che evidenzia lo sfasamento proporzionale alla pulsazione moltiplicato per t_0."
  },
  {
    "objectID": "fft.html#trasformazione-di-unequazione-differenziale-in-unequazione-algebrica-nel-dominio-delle-frequenze-funzione-di-trasferimento",
    "href": "fft.html#trasformazione-di-unequazione-differenziale-in-unequazione-algebrica-nel-dominio-delle-frequenze-funzione-di-trasferimento",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.8 Trasformazione di un’equazione differenziale in un’equazione algebrica nel dominio delle frequenze: Funzione di Trasferimento",
    "text": "2.8 Trasformazione di un’equazione differenziale in un’equazione algebrica nel dominio delle frequenze: Funzione di Trasferimento\nSupponiamo di avere un sistema regolato da una equazione differenziale del secondo ordine:\n\n\\frac{d^2y(t)}{dt^2} + a\\frac{dy(t)}{dt} + b~y(t) = c~u(t)\n\ndove la u(t) è la forzante, ovvero l’ingresso, mentre la y(t) è la risposta, ovvero l’uscita.\nTrasformando secondo Fourier la derivata prima e seconda dell’uscita, tenendo presente le proprietà enunciate in Tabella 1, si ottiene:\n\n\\frac{dy(t)}{dt}\\rightarrow i\\omega Y(\\omega)\n e \n\\frac{d^2y(t)}{dt^2}\\rightarrow i\\omega(i\\omega Y(\\omega))\n e quindi la equazione differenziale diventa: \n(i\\omega)^2Y(\\omega) + i\\omega a~Y(\\omega) + b~Y(\\omega) = c~U(\\omega)\n che non è altro se non una equazione algebrica che può essere risolta rispetto all’uscita: \nY(\\omega) = \\frac{c}{b + i\\omega~a + (i\\omega)^2}~U(\\omega)\n\nTale relazione indica che la trasformata dell’uscita del sistema è pari alla trasformata dell’ingresso moltiplicata per una funzione anch’essa della frequenza (o pulsazione) che dipende solamente dalla forma dell’equazione differenziale che regola il sistema stesso, ovvero dai parametri a, b e c. Tale funzione complessa viene definita Funzione di Trasferimento.\nPer convenzione la funzione di trasferimento viene indicata come H(\\omega) per cui la precedente relazione si scrive in forma generale: \nY(\\omega) = H(\\omega)U(\\omega)\n\\tag{12}\nDalla precedente è immediato ricavare la funzione di trasferimento come rapporto delle trasformate: \nH(\\omega) = \\frac{Y(\\omega)}{U(\\omega)}\n In generale l’uscita di un sistema lineare si può ottenere in due maniere:\n\nin frequenza: moltiplicazione della trasformata dell’ingresso per la funzione di trasferimento\nnel tempo: convoluzione tra ingresso ed antitrasformata della funzione di trasferimento (risposta del sistema ad un impulso ideale).\n\nLa funzione di trasferimento, oltre che esplicitamente ricavata dalla relazione differenziale data dalla fisica del fenomeno, può essere ricavata trasformando la risposta del sistema ad un impulso.\nPer fare ciò introduciamo il concetto di delta di Dirac che modella un impulso ideale. Essa vale infinito per un tempo infinitesimo. Si definisce \\delta(t-t_0) quella funzione che vale infinito per t = t_0 ed è nulla altrove. Se integrata tale funzione, avendo dominio infinitesimo ma valore infinito, risulta: \n\\int_{-\\infty}^\\infty \\delta(t-t_0)~dt = 1\n\nCalcoliamone dunque la sua trasformata: \n\\delta(t)\\rightarrow \\int_{-\\infty}^\\infty \\delta(t)~e^{-i\\omega t}~dt = \\int_{-\\infty}^\\infty \\delta(t)~e^{-i\\omega (t=0)}~dt = \\int_{-\\infty}^\\infty \\delta(t) = 1\\quad \\forall\\omega\n\nSe quindi si impiega tale funzione come ingresso ad un generico sistema, si ottiene che U(\\omega) = 1 per ogni frequenza e quindi Y(\\omega) = H(\\omega). Questo è il principale motivo per il quale chi si occupa di identificazione/caratterizzazione dei sistemi meccanici impiega martelletti strumentati per imporre degli impulsi sulle strutture e registrarne le vibrazioni nei diversi punti di interesse per ricavare la h(t) ovvero, tramite trasformata di Fourier, la H(\\omega) che lega sollecitazioni nel punto di applicazioni dell’impulso alla risposta nel punto di registrazione delle vibrazioni. Torneremo su questo argomento nel terzo paragrafo.\nNel prossimo paragrafo evidenziamo un ulteriore punto di vista sulla funzione di trasferimento che può essere vista come quella funzione che in modulo indica l’attenuazione di una qualsiasi armonica venga posta in ingresso ed in fase il suo sfasamento. Da ciò prende anche il nome di funzione di trasferimento ‘sinusoidale’."
  },
  {
    "objectID": "fft.html#funzione-di-trasferimento-sinusoidale",
    "href": "fft.html#funzione-di-trasferimento-sinusoidale",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.9 Funzione di trasferimento sinusoidale",
    "text": "2.9 Funzione di trasferimento sinusoidale\nConsideriamo un sistema dinamico lineare caratterizzato da una funzione di trasferimento H(\\omega). Iniettiamo un ingresso puramente armonico di tipo sinusoidale, come schematizzato nel diagramma a blocchi di Figura 6.\n\n\n\n\n\n\nFigura 6: Rappresentazione ingresso-uscita di un sistema dinamico regolato da equazione differenziale lineare.\n\n\n\nImponendo in ingresso u(t)=\\sin(\\omega_0 t) vogliamo determinare l’uscita y(t). Vedremo che si determina in maniera immediata dalla conoscenza di modulo e fase della funzione di trasferimento in corrispondenza della pulsazione dell’ingresso.\nPer determinarlo passiamo attraverso le trasformate, dunque trasformiamo l’ingresso: \nu(t)=\\sin(\\omega_0 t) \\otimes U(\\omega) = \\int_{-\\infty}^\\infty \\sin(\\omega_0 t)~e^{-i\\omega t}~ dt = \\\\\n= \\int_{-\\infty}^\\infty \\sin(\\omega_0 t)(\\cos(\\omega t) - i\\sin(\\omega t)) ~dt\n\nTale trasformata vale chiaramente zero \\forall\\omega \\neq\\pm\\omega_0 grazie alla proprietà di ortonormalità delle funzioni armoniche. Per \\omega = \\omega_0 ed \\omega = -\\omega_0 occorre invece calcolarne i valori.\n\n\\begin{aligned}\nU(\\omega_0) &= \\int_{-\\infty}^\\infty \\sin(\\omega_0 t)(- i\\sin(\\omega_0 t)) ~dt = -i\\int_{-\\infty}^\\infty \\sin^2(\\omega_0 t)~dt \\\\\n&= -i \\int_{-\\infty}^\\infty \\frac{1-\\cos(2\\omega_0 t)}{2}~dt = -\\frac{i}{2} \\cdot\\infty \\\\\nU(-\\omega_0) &= \\int_{-\\infty}^\\infty \\sin(\\omega_0 t)(i\\sin(\\omega_0 t)) ~dt = i\\int_{-\\infty}^\\infty \\sin^2(\\omega_0 t)~dt \\\\\n&= i \\int_{-\\infty}^\\infty \\frac{1-\\cos(2\\omega_0 t)}{2}~dt = \\frac{i}{2} \\cdot\\infty \\\\\n\\end{aligned}\n\nVolendo rappresentare lo spettro della funzione seno si ha dunque il grafico in Figura 7.\n\n\n\n\n\n\nFigura 7: Rappresentazione dello spettro della funzione sinusoidale. In modulo ha due componenti di valore infinito del primo ordine con modulo 1/2 (ovvero due delta di Dirac di valore 1/2). Come fase due valori antisimmetrici di 90° e -90°. Globalmente lo spettro delle componenti a pulsazioni positive risultano essere i valori coniugati delle componenti a pulsazioni negative, come risulta anche dall’equazione Equazione 8.\n\n\n\nGlobalmente la trasformata dell’ingresso si può scrivere quindi come somma di due delta di Dirac: \nU(\\omega) = \\frac{i}{2}\\delta(\\omega + \\omega_0)- \\frac{i}{2}\\delta(\\omega-\\omega_0)\n dove con delta di Dirac \\delta(\\omega-\\omega_0) si intende la funzione che vale infinito per \\omega=\\omega_0) ed è nulla altrove. Se integrata, tale funzione, avendo dominio infinitesimo ma valore infinito, risulta \\int_{-\\infty}^\\infty\\delta(\\omega-\\omega_0)~d\\omega. Se come argomento dell’integrale si ha una generica funzione H(\\omega), risulta \\int_{-\\infty}^\\infty H(\\omega)\\delta(\\omega-\\omega_0)~d\\omega = H(\\omega_0). Questo semplicemente perché l’infinito rappresentato dalla delta di Dirac moltiplica il valore della funzione in corrispondenza della pulsazione \\omega_0 facendo assumere al prodotto un valore infinito di modulo H(\\omega_0) che, integrato su di un dominio infinitesimo produce un risultato finito pari al valore assunto dalla funzione in corrispondenza della pulsazione \\omega_0). A questo punto è immediato determinare il valore della trasformata dell’uscita: \nY(\\omega) = H(\\omega)U(\\omega) = H(\\omega) \\left( \\frac{i}{2}\\delta(\\omega + \\omega_0) - \\frac{i}{2}\\delta(\\omega - \\omega_0) \\right)\n che porta ad avere una somma di due delta con moduli pari al valore della funzione di trasferimento in corrispondenza dei due infiniti: \nY(\\omega) = H(-\\omega_0)\\frac{i}{2}\\delta(\\omega+\\omega_0) - H(\\omega_0)\\frac{i}{2}\\delta(\\omega-\\omega_0)\n\nLa funzione di trasferimento può essere scomposta in modulo e fase: \nH(\\omega) = M(\\omega)~e^{-i\\Phi(\\omega)}\n per cui si ha: \nY(\\omega)=M(\\omega_0)\\frac{i}{2}\\delta(\\omega + \\omega_0)~e^{-i\\Phi(\\omega_0)} - M(\\omega_0)\\frac{i}{2}\\delta(\\omega - \\omega_0)~e^{-i\\Phi(\\omega_0)}\n In cui si sono semplicemente sostituiti i valori e considerata la proprietà dello spettro si un segnale reale: modulo simmetrico e fase antisimmetrica, secondo la Equazione 8.\nConsiderando l’equazione di Eulero: e^{i\\Phi(\\omega_0)}=\\cos(\\Phi(\\omega_0)) + i\\sin(\\Phi(\\omega_0)) si ottiene, dopo semplice manipolazione: \n\\frac{Y(\\omega)}{M(\\omega_0)} = \\cos(\\Phi(\\omega_0)) \\left[ \\frac{i}{2}\\delta(\\omega+\\omega_0) - \\frac{i}{2}\\delta(\\omega-\\omega_0) \\right] + \\\\\n+ \\sin(\\Phi(\\omega_0)) \\left[ \\frac{1}{2}\\delta(\\omega+\\omega_0) + \\frac{1}{2}\\delta(\\omega-\\omega_0) \\right]\n\nDel primo termine sappiamo immediatamente calcolare l’antitrasformata avendo appena calcolato la trasformata della funzione seno. Il secondo termine è anche immediatamente antitrasformabile in quanto vale: \n\\cos(\\omega_0 t) = \\frac{1}{2}\\delta(\\omega+\\omega_0) + \\frac{1}{2}\\delta(\\omega-\\omega_0)\n\nIn definitiva, quindi: \ny(y) = M(\\omega_0)\\cos(\\Phi(\\omega_0)) \\sin(\\omega_0 t) +  M(\\omega_0)\\sin(\\Phi(\\omega_0)) \\cos(\\omega_0 t)\n ovvero: \ny(t) = M(\\omega_0)\\sin(\\omega_0t + \\Phi(\\omega_0))\n Che esprime il fatto che se si pone in ingresso ad un sistema regolato da equazioni differenziali lineari un ingresso armonico di modulo unitario e pulsazione \\omega_0, l’uscita sarà un’armonica di pari pulsazione \\omega_0 ma di modulo pari al modulo della funzione di trasferimento H(\\omega_0) calcolata per la pulsazione \\omega_0 e sfasata della fase della funzione di trasferimento \\Phi(\\omega_0)) calcolata per la stessa pulsazione \\omega_0.\n\n\n\n\n\n\nFigura 8: Trasformata del seno\n\n\n\nA tale risultato era possibile giungere semplicemente considerando la Equazione 12: \n\\begin{aligned}\nY(\\omega) &= H(\\omega)U(\\omega)=M_H(\\omega)~e^{i\\Phi_H(\\omega)} M_U(\\omega)~e^{i\\Phi_U(\\omega)} \\\\\n&= M_H(\\omega) M_U(\\omega)~e^{i(\\Phi_H(\\omega) + \\Phi_U(\\omega))}\n\\end{aligned}\n che esprime appunto il fatto che i moduli si moltiplicano e le fasi si sommano."
  },
  {
    "objectID": "fft.html#rappresentazione-dello-spettro-di-un-segnale-campionato-mediante-dft",
    "href": "fft.html#rappresentazione-dello-spettro-di-un-segnale-campionato-mediante-dft",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.10 Rappresentazione dello spettro di un segnale campionato mediante DFT",
    "text": "2.10 Rappresentazione dello spettro di un segnale campionato mediante DFT\nNell’elaborazione dei segnali occorre passare a segnali di tipo discreto poiché i dati acquisiti dal modulo di acquisizione digitale e registrati sono delle sequenze finite di valori quantizzati, ovvero dei vettori come già visto. Dunque, nell’elaborazione computerizzata dei segnali non si manipola un segnale s(t), ma un vettore [s(1), s(2), \\dots, s(N)] di N valori s(n) campionati alla frequenza di campionamento f_c = 1/T_c.\n\n\n\n\n\nSegnale digitale campionato da un segnale continuo con 20 campioni\n\n\n\n\nLa Trasformata di Fourier Discreta (DFT) è formulata così: \ns(n)\\rightarrow S(k) = \\sum_{n=1}^N s(n)~e^{-\\frac{2\\pi i}{N}k(n-1)}\\quad k=0, 1, \\dots, N-1\n\nCome era prevedibile, ciascun elemento S(k) della trasformata del segnale discreto, ovvero del vettore, si può calcolare come prodotto di due vettori: \nS(k) = [s(1), s(2), \\dots, s(N)]\\cdot[1, e^{-\\frac{2\\pi i}{N}k}, e^{-\\frac{2\\pi i}{N}k~2},\\dots, e^{-\\frac{2\\pi i}{N}k~N}]^T\n Ovvero tra il vettore corrispondente al segnale discreto ed uno dei vettori corrispondenti alla base (uno dei segnali discreti complessi e^{-\\frac{2\\pi i}{N}kn} base della scomposizione). Anch’essi vettori ortonormali, in altre parole facente parte dei versori nello spazio \\mathbb R^N. Si noti che per ricavare le componenti tramite prodotto scalare definito in Equazione 5 manca la normalizzazione per N.\nLa DFT la si può scrivere evidenziando la corrispondenza tra i vettori nel dominio del tempo discreto s(n) e della frequenza discreta, ovvero lo spettro S(k): \n[s(1), s(2), \\dots, s(N)]\\rightarrow [S(1), S(2), \\dots, S(N)]\n\nSi noti come lo spettro [S(1), S(2), \\dots, S(N)] abbia lo stesso numero di campioni N del segnale [s(1), s(2), \\dots, s(N)].\nÈ importante ora capire: cosa rappresentano i diversi coefficienti S(k)? A che frequenze corrispondono i vari k?\nConsideriamo S(1) che corrisponde a frequenza nulla: K parte da 0. Stiamo moltiplicando per un segnale costante che possiamo immaginare come un segnale armonico avente periodo infinito (inverso della frequenza: 1/0 = +\\infty).\nEsso è pari a: \nS(1)=S(k=0)=\\sum_{n=1}^N s(n)~e^0 = \\sum_{n=1}^N s(n)\n Quindi è pari alla somma dei campioni del segnale. Si noti che si ha quindi S(1) = N \\bar{s}, sove \\bar s è la media del segnale sull’intervallo considerato.\nConsideriamo S(2): \nS(2)=S(k=1)=[s(1), s(2), \\dots, s(N)]\\cdot[1, e^{-\\frac{2\\pi i}{N}}, e^{-\\frac{2\\pi i}{N}\\cdot 2},\\dots, e^{-\\frac{2\\pi i}{N}\\cdot N}]^T\n\nQuindi S(2), divisa per N, fornirà la componente del segnale s(n) lungo la prima armonica. Si noti infatti che l’esponenziale complesso ha fase che parte da 0 ed arriva a 2\\pi esattamente in N campioni eseguendo quindi un solo periodo o giro per il fasore corrispondente. Il periodo totale di campionamento è pari a (N-1)T_c\nDi conseguenza la frequenza corrispondente sarà \\frac{1}{(N-1)T_c}.\nConsideriamo S(3): \nS(3)=S(k=3)=[s(1), s(2), \\dots, s(N)]\\cdot[1, e^{-\\frac{4\\pi i}{N}}, e^{-\\frac{4\\pi i}{N}\\cdot 2},\\dots, e^{-\\frac{4\\pi i}{N}\\cdot N}]^T\n\nS(3), diviso sempre per N è la componente del segnale s(n) lungo la seconda armonica. Si noti che l’esponenziale complesso ha fase che parte da 0 ed arriva a 4\\pi esattamente in N campioni eseguendo quindi due periodi, o giri, per il fasore corrispondente. Di conseguenza la frequenza corrispondente sarà \\frac{2}{(N-1)T_c}. E così via.\nContinuando in questo modo, l’ultimo valore dello spettro corrisponderebbe alla frequenza 1/T_c pari alla frequenza di campionamento f_c. Ma sappiamo che ciò non è possibile. Il teorema di Nyquist assegna infatti significato alla sola banda 0\\div f_c/2. è questo il motivo per cui dalla frequenza di Nyquist (f_c/2) in poi si ha una ripetizione dello spettro tramite le componenti negative che, assieme alle corrispondenti positive, consentono di ottenere le armoniche come segnali reali.\n\n\n\n\n\n\nFigura 9: Rappresentazione dei coefficienti della scomposizione di Fourier mediante DFT. La trasformazione possiede contenuto informativo sino alla frequenza di Nyquist, oltre si ha uno specchio delle componenti (per segnali reali il modulo sarà simmetrico, la fase antisimmetrica).\n\n\n\nSi veda la Sezione 3.1.1 per un esempio."
  },
  {
    "objectID": "fft.html#tabella-riassuntiva",
    "href": "fft.html#tabella-riassuntiva",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "2.11 Tabella riassuntiva",
    "text": "2.11 Tabella riassuntiva\n\n\n\nTabella 2: Riassunto delle relazioni principali.\n\n\n\n\n\n\n\n\n\n\nOggetto\nSviluppo in serie o scomposizione dell’oggetto\nCalcolo coefficienti\n\n\n\n\nVettore \\mathbf v\n\\mathbf{v} = \\alpha \\mathbf{e}_1 + \\beta \\mathbf{e}_2\ndove \\mathbf e_1, \\mathbf e_2 sono i versori di una base ortogonale\n\\alpha = \\mathbf{v}\\cdot\\mathbf{e}_1\n\\beta = \\mathbf{v}\\cdot\\mathbf{e}_2\n\n\nSegnale periodico g(t) nel tempo continuo (sviluppo di Fourier)\nSegnale periodico g(t) nel tempo continuo (sviluppo di Fourier)\ng(t)=\\frac{a_0}{2}+\\sum_{n=1}^\\infty a_n\\cos(\\omega_nt) +\\sum_{n=1}^\\infty b_n\\sin(\\omega_nt)\ndove \\omega_n=2\\pi nf_0\na_n=\\frac{2}{T}\\int_0^Tg(t)\\cos(\\omega_nt)~dt\nb_n=\\frac{2}{T}\\int_0^Tg(t)\\sin(\\omega_nt)~dt\n\n\nSegnale periodico g(t) nel tempo continuo (sviluppo mediante fasori)\ng(t)=\\sum_{n=-\\infty}^\\infty G_n~e^{i\\omega_n t}\ndove \\omega_n = 2\\pi n f_0\nG_n=\\frac{1}{T}\\int_0^T g(t)~e^{-i\\omega_nt}~dt\n\n\nSegnale generico, NON periodico nel tempo continuo\ng(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^\\infty G(\\omega)~e^{i\\omega t}~dt\nG(\\omega=\\frac{1}{T}\\int_0^T g(t)~e^{-i\\omega_nt}~dt\n\n\nSegnale digitale s(n)=[s(1),s(2),\\dots,s(N)]\ns(n)=\\frac{1}{N}\\sum_{k=0}^{N-1}S(k)~e^{\\frac{2\\pi i}{N}k(n-1)}\nn=1, 2, \\dots, N\nS(K)=\\sum_{n=1}^{N}s(n)~e^{-\\frac{2\\pi i}{N}k(n-1)}\nk=0, 1, \\dots, N-1\n\n\n\n\n\n\nNotare che per segnali digitali, campionati in un intervallo di tempo finito e quantizzati, non ha senso chiedersi se siano periodici o meno. Semplicemente non lo sappiamo. In ogni caso la minima armonica contenuta vale 1/(intervallo di acquisizione) e ci saranno le sue multiple in modo analogo ai segnali periodici nel tempo continuo."
  },
  {
    "objectID": "fft.html#esempio-1",
    "href": "fft.html#esempio-1",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "3.1 Esempio",
    "text": "3.1 Esempio\n\n3.1.1 Creiamo una serie di dati\nCreiamo una serie temporale ottenuta combinando sinusoidi con diversi parametri di ampiezza w, frequenza f e fase \\phi. Per farlo definiamo una funzione di supporto:\n\nsignal &lt;- function(t, pars, rad=FALSE) {\n  stopifnot(is.data.frame(pars))\n  if (!rad) {\n    pars$phi &lt;- pars$phi/180*pi\n    pars$f &lt;- 2*pi*pars$f\n  }\n  with(\n    pars,\n    map_dbl(t, \\(t) map_vec(seq_along(w), ~ w[.]*sin(t*f[.]+phi[.])) %&gt;% sum())\n  )\n}\n\nOra creiamo un segnale composto da tre sinusoidi,\n\npars &lt;- tibble(\n  w = c(1, 0.2, 0.5, 0.25),\n  f = c(4, 10, 2, 30),\n  phi = c(0, 0, 0, 90)\n)\n\n\n\n\nTabella dei parametri\n\n\nw (-)\nf (Hz)\n\\phi (°)\n\n\n\n\n1.00\n4\n0\n\n\n0.20\n10\n0\n\n\n0.50\n2\n0\n\n\n0.25\n30\n90\n\n\n\n\n\n\ns &lt;- tibble(\n  t = seq(0, 10, length.out = 5000),\n  y = signal(t, pars, rad=FALSE) + rnorm(length(t), 0, 0.5) + 1.25\n) \n\ns %&gt;% \n  ggplot(aes(x=t, y=y)) +\n  geom_line(linewidth=0.1)\n\n\n\n\nSegnale composto, con rumore normale\n\n\n\n\n\n\n3.1.2 Spettrogramma mediante FFT\nR mette a disposizione la funzione fft() nella libreria base:\n\ns.fft &lt;- fft(s$y)\n\nsummary(s.fft)\n\n Length   Class    Mode \n   5000 complex complex \n\n\nQuindi la trasformata è un vettore complesso con lo stesso numero di osservazioni del segnale iniziale.\n\ns %&gt;% \n  mutate(\n    i = 1:n(),\n    fft = fft(y),\n    intensity = Mod(fft),\n    phase = Arg(fft)/pi*180\n  ) %&gt;% \n  ggplot(aes(x=i, y=intensity)) +\n  geom_line()\n\n\n\n\nFFT grezza\n\n\n\n\nCosa c’è in ascissa? La trasformata copre un intervallo di frequenze [0, N/T], con T=N\\delta t la durata complessiva del segnale. L’intensità dei picchi (cioè il modulo del valore complesso) corrisponde invece all’ampiezza delle componenti, scalata con il numero di osservazioni:\n\ns.fft &lt;- s %&gt;% \n  mutate(\n    i = 1:n()-1,\n    fft = fft(y),\n    intensity = Mod(fft) / n() * 2,\n    phase = Arg(fft)/pi*180,\n    f = i / max(t)\n  ) %&gt;% \n  slice_head(\n    n = nrow(.)/2\n  )\n\nMessa in grafico otteniamo lo spettro in frequenza del segnale:\n\ns.fft %&gt;% \n  ggplot(aes(x=f, y=intensity)) +\n  geom_vline(xintercept=pars$f, color=\"red\", linewidth=0.25) +\n  geom_line(linewidth=0.2) +\n  geom_point(size=0.5) +\n  coord_cartesian(xlim=c(0, 35)) +\n  labs(x=\"frequenza (Hz)\", y=\"intensità (-)\")\n\n\n\n\nFFT riscalata. In rosso le frequenze originali nella tabella pars"
  },
  {
    "objectID": "fft.html#finestre",
    "href": "fft.html#finestre",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "3.2 Finestre",
    "text": "3.2 Finestre\nConsideriamo un segnale sinusoidale privo di disturbo, campionato per un tempo pari a 10 volte il suo periodo più mezzo periodo:\n\npars &lt;- tibble(\n  w = c(1),\n  f = c(10),\n  phi = c(0)\n)\n\ns &lt;- tibble(\n  t = seq(0, 1+1/pars$f/2, length.out = 512),\n  y = signal(t, pars, rad=FALSE) + rnorm(length(t), 0, 0.0)\n) \n\ns %&gt;% \n  ggplot(aes(x=t, y=y)) +\n  geom_line()\n\n\n\n\n\n\n\n\nOra osserviamo la FFT\n\ns %&gt;% \n  mutate(\n    f = 0:(n()-1)/max(t),\n    fft = fft(y),\n    intensity = Mod(fft) / n() * 2,\n    phase = Arg(fft)/pi*180\n  ) %&gt;% \n  slice_head(n=nrow(.)/2) %&gt;% \n  ggplot(aes(x=f, y=intensity)) +\n  geom_vline(xintercept=10, linetype=2, color=\"red\") +\n  geom_spoke(aes(angle=pi/2, y=0, radius=intensity), linewidth=0.2) +\n  geom_point(shape=21) +\n  coord_cartesian(xlim=c(0, 100))\n\n\n\n\n\n\n\n\nCome si vede, la FFT è allargata, in maniera inattesa, attorno al picco a 10 Hz: come mai?\nBisogna ricordare che la FFT assume che il segnale sia periodico e campionato per un numero di cicli interi. Cioè è come se il segnale si ripetesse all’infinito uguale a se stesso dopo (e prima) la fine del campionamento. Nel nostro caso, quindi, è come se il segnale fosse come il seguente:\n\ns %&gt;% mutate(step=\"A\") %&gt;% \n  bind_rows(mutate(s, step=\"B\", t=t+last(t))) %&gt;% \n  ggplot(aes(x=t, y=y, color=step)) +\n  geom_line()\n\n\n\n\n\n\n\n\nÈ evidente come ogni \\Delta T=1.05+0.05 secondi ci sia un evento con una discontinuità sulla derivata del segnale, che si ripete periodicamente. Cioè si ha un evento con un ampio contenuto in frequenza (per ottenere uno spigolo bisogna sommare molte componenti!) attorno alla frequenza pari all’inverso della durata del campionamento. È altrettanto evidente come, ad eccezione del caso in cui la durata del campionamento è un multiplo esatto di tutti i periodi contenuti nel segnale, ciò significa che la parte a bassa frequenza dello spettro sarà sempre sporcata alla frequenza pari all’inverso della durata del campionamento.\n\n\n\n\n\n\nEsercizio\n\n\n\nProvare a modificare i parametri di frequenza e durata del campionamento per osservare il risultato.\n\n\nPer mitigare questo problema si ricorre alla finestratura (windowing) del segnale: si moltiplica il segnale per una funzione che va a zero, o quasi, all’inizio e alla fine del campionamenti. Esistono diverse funzioni di finestratura, le più utilizzate sono quella di Hamming e quella di Hann.\nIl pacchetto gsignal le mette a disposizione entrambi (ed altre):\n\ns %&gt;% \n  mutate(\n    i = 1:n(),\n    win = hann(n()),\n    yw = y * win\n  ) %&gt;% \n  ggplot(aes(x=i)) +\n  geom_line(aes(y=win), color=\"red\", linetype=2) +\n  geom_line(aes(y=-win), color=\"red\", linetype=2) +\n  geom_line(aes(y=yw))\n\n\n\n\n\n\n\n\nA questo punto il segnale è ovviamente perfettamente periodico e, se calcoliamo la FFT del segnale modificato con la finestra di Hann, otteniamo:\n\ns %&gt;% \n  mutate(\n    f = 0:(n()-1)/max(t),\n    yw = hann(n()) * y,\n    fft = fft(yw),\n    intensity = Mod(fft) / n()*2,\n    phase = Arg(fft)/pi*180\n  ) %&gt;% \n  slice_head(n=nrow(.)/2) %&gt;% \n  ggplot(aes(x=f, y=intensity)) +\n  geom_vline(xintercept=10, linetype=2, color=\"red\") +\n  geom_spoke(aes(angle=pi/2, y=0, radius=intensity), linewidth=0.2) +\n  geom_point(shape=21) +\n  coord_cartesian(xlim=c(0, 100))\n\n\n\n\n\n\n\n\nPossiamo osservare come il contributo della durata del campionamento sia pressoché svanito, anche se risulta ovviamente ridotta l’intensità dei picchi a 10 Hz, dato che l’ampiezza media del segnale è anch’essa ridotta.\n\n\n\n\n\n\nEsercizio\n\n\n\nProvare a cambiare funzione finestra utilizzando hamming() o una delle altre finestre messe a disposizione da gsignal."
  },
  {
    "objectID": "fft.html#footnotes",
    "href": "fft.html#footnotes",
    "title": "Trasformazione nel dominio delle frequenze",
    "section": "Note",
    "text": "Note\n\n\nF. Angrilli, Misure Meccaniche e Termiche, Cedam 2005↩︎"
  },
  {
    "objectID": "esercizi.html",
    "href": "esercizi.html",
    "title": "Esercizi",
    "section": "",
    "text": "1 Applicazioni pratiche ed esercizi\n\n\n\n\n\n\n\n   \n     \n     \n       Ordinare per\n       Predefinito\n         \n          Titolo\n        \n         \n          Categorie\n        \n         \n          Data - Meno recente\n        \n         \n          Data - Più recente\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nData\n\n\nTitolo\n\n\nAutore/Autrice\n\n\nDescrizione\n\n\nCategorie\n\n\nTempo per completare la lettura\n\n\n\n\n\n\n24 feb 2025\n\n\n3. Compensazione (o Misura) dinamica\n\n\nMariolino De Cecco\n\n\nEsercizi sulla compensazione dinamica delle misure mediante analisi dello spettro e filtraggio offline. \n\n\nsignal, filter, spectrum\n\n\n5 minuti\n\n\n\n\n24 feb 2025\n\n\n4. Modulazione di ampiezza\n\n\nMariolino De Cecco\n\n\nEsercizi sulla modulazione di ampiezza delle misure mediante analisi dello spettro e filtraggio offline. \n\n\nsignal, filter, spectrum\n\n\n9 minuti\n\n\n\n\n24 feb 2025\n\n\nFiltri\n\n\nMariolino De Cecco e Paolo Bosetti\n\n\n\n\n\nsignal, filter, spectrum\n\n\n7 minuti\n\n\n\n\n\nNessun risultato"
  },
  {
    "objectID": "esercizi/2_4_Modulazione in ampiezza.html",
    "href": "esercizi/2_4_Modulazione in ampiezza.html",
    "title": "4. Modulazione di ampiezza",
    "section": "",
    "text": "Quanto segue richiede questi pacchetti:\n\nlibrary(tidyverse)\nlibrary(plotly)\nlibrary(gsignal)\n\nSe necessario installarli con install.packages() o mediante la GUI."
  },
  {
    "objectID": "esercizi/2_4_Modulazione in ampiezza.html#in-un-colpo-solo",
    "href": "esercizi/2_4_Modulazione in ampiezza.html#in-un-colpo-solo",
    "title": "4. Modulazione di ampiezza",
    "section": "4.1 In un colpo solo",
    "text": "4.1 In un colpo solo\nNella parte precedente, la tabella ym è stata costruita gradualmente, allo scopo di illustrare la composizione del segnale simulato. Guardando le operazioni nel loro complesso, la procedura è in realtà più semplice:\n\ntibble(\n  t = seq(0, duration, by = 1/fc),\n  y = signal(t, pars_m) + \n      rnorm(length(t), 0, pars_m$w[1]/10),    # segnale \n  fft = fft(y),                               # e sua FFT\n  y_in = signal(t, pars_r),                   # rumore interferente\n  fft_in = fft(y_in),                         # e sua FFT\n  y_m = (1 + m * y) * cos(2 * pi * fp * t),   # modulante\n  fft_m = fft(y_m),                           # e sua FFT\n  y_m_in = y_m + y_in,                        # modulante + interferente\n  fft_m_in = fft(y_m_in)                      # e sua FFT\n) %&gt;%\n  # aggiungo la frequenza\n  mutate(\n    f = 0:(length(t)-1)/max(t),\n  ) %&gt;% \n  # prendo solo le colonne frequenza e fft\n  select(f, contains(\"fft\")) %&gt;% \n  # riorganizzo la tabella\n  pivot_longer(\n    -f, \n    names_to = \"signal\",\n    values_to = \"fft\",\n    names_transform = ~ fft_names[.]\n  ) %&gt;% \n  # aggiungo l'intensità\n  mutate(\n    intensity = Mod(fft) / length(t)*2\n  ) %&gt;% \n  ggplot(aes(x=f, y=intensity, color=signal)) +\n  geom_line() +\n  xlim(c(0,500))"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Un corso offerto agli studenti dell’Università di Trento."
  },
  {
    "objectID": "r_brief.html",
    "href": "r_brief.html",
    "title": "R minimo",
    "section": "",
    "text": "Nota\n\n\n\nI blocchi di codice di seguito sono live: è possibile modificarli, eseguirli e osservare il risultato!\n\n\n\n\nL’assegnazione di variabili avviene con il simbolo &lt;-, il quale funziona anche in direzione opposta (-&gt;):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nI vettori si creano con la funzione c() (come combine):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe sequenze regolari con passo 1 si creano con l’operatore ::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti che il punto per R è un carattere qualsiasi, quindi può fare parte di nomi di variabili.\nLe sequenze con passo diverso da 1 si ottengono con seq():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSe si vuole specificare il numero di elementi invece che il passo:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nUna matrice si crea con la funzione matrix(). Di default i valori vengono passati per colonne:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti che le opzioni delle funzioni possono essere passate per posizione o per nome. Se si usa il nome, possono essere passate in qualsiasi posizione.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nMatrici e vettori in R hanno base 1, cioè il primo elemento ha indice 1 (anziché 0 come in C/C++ e Python).\nPer indicizzare un vettore si usano le parentesi quadrate:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPer una matrice si passano due argomenti tra le parentesi quadrate, omettendo uno o entrambi se si vile estrarre un’intera colonna o intera riga. Il primo argomento è quello di riga:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nÈ possibile estrarre sottoinsiemi di elementi passando alle parentesi quadrate vettori di indici:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInfine, è possibile usare vettori di valori logici (TRUE o FALSE, abbreviabili in T e F). In questo caso, se il vettore di indici è più breve del vettore/matrice originale, si assume ripetuto:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIn R ogni variabile è intrinsecamente un vettore e tutte (o quasi) le funzioni e operatori base sono vettorializzate, cioè operano elemento per elemento. Ciò spiega perché l’espressione v.up[v.up &gt; 2] funziona: v.up &gt; 2 restituisce un vettore di valori logici lungo come v.up, valutando la diseguaglianza per ogni elemento di v.up.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nMa anche:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCiò fa sì che sia raramente necessario utilizzare dei loop.\n\n\n\nQuando proprio è necessario:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nanche se bastava (ed è molto più efficiente):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#variabili",
    "href": "r_brief.html#variabili",
    "title": "R minimo",
    "section": "",
    "text": "L’assegnazione di variabili avviene con il simbolo &lt;-, il quale funziona anche in direzione opposta (-&gt;):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#vettori",
    "href": "r_brief.html#vettori",
    "title": "R minimo",
    "section": "",
    "text": "I vettori si creano con la funzione c() (come combine):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe sequenze regolari con passo 1 si creano con l’operatore ::\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti che il punto per R è un carattere qualsiasi, quindi può fare parte di nomi di variabili.\nLe sequenze con passo diverso da 1 si ottengono con seq():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSe si vuole specificare il numero di elementi invece che il passo:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#matrici",
    "href": "r_brief.html#matrici",
    "title": "R minimo",
    "section": "",
    "text": "Una matrice si crea con la funzione matrix(). Di default i valori vengono passati per colonne:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti che le opzioni delle funzioni possono essere passate per posizione o per nome. Se si usa il nome, possono essere passate in qualsiasi posizione.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#indicizzazione",
    "href": "r_brief.html#indicizzazione",
    "title": "R minimo",
    "section": "",
    "text": "Matrici e vettori in R hanno base 1, cioè il primo elemento ha indice 1 (anziché 0 come in C/C++ e Python).\nPer indicizzare un vettore si usano le parentesi quadrate:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPer una matrice si passano due argomenti tra le parentesi quadrate, omettendo uno o entrambi se si vile estrarre un’intera colonna o intera riga. Il primo argomento è quello di riga:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nÈ possibile estrarre sottoinsiemi di elementi passando alle parentesi quadrate vettori di indici:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInfine, è possibile usare vettori di valori logici (TRUE o FALSE, abbreviabili in T e F). In questo caso, se il vettore di indici è più breve del vettore/matrice originale, si assume ripetuto:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#funzioni-vettorializzate",
    "href": "r_brief.html#funzioni-vettorializzate",
    "title": "R minimo",
    "section": "",
    "text": "In R ogni variabile è intrinsecamente un vettore e tutte (o quasi) le funzioni e operatori base sono vettorializzate, cioè operano elemento per elemento. Ciò spiega perché l’espressione v.up[v.up &gt; 2] funziona: v.up &gt; 2 restituisce un vettore di valori logici lungo come v.up, valutando la diseguaglianza per ogni elemento di v.up.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nMa anche:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCiò fa sì che sia raramente necessario utilizzare dei loop."
  },
  {
    "objectID": "r_brief.html#cicli-e-loop",
    "href": "r_brief.html#cicli-e-loop",
    "title": "R minimo",
    "section": "",
    "text": "Quando proprio è necessario:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nanche se bastava (ed è molto più efficiente):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#liste",
    "href": "r_brief.html#liste",
    "title": "R minimo",
    "section": "3.1 Liste",
    "text": "3.1 Liste\nLe liste si creano con la funzione list():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti che NA significa not available e rappresenta un elemento mancante.\nPer accedere agli elementi di una lista si usano sempre le parentesi quadrate:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti però che usando [] si ottiene di nuovo una lista (una sotto-lista). Per ottenere l’elemento contenuto in una data posizione è necessario usare la doppia parentesi [[]]:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#le-tabelle",
    "href": "r_brief.html#le-tabelle",
    "title": "R minimo",
    "section": "3.2 Le tabelle",
    "text": "3.2 Le tabelle\nLe tabelle sono la struttura più usata in R e si creano con la funzione data.frame(). Noi utilizzeremo però la funzione tibble(): una versione più evoluta che fa parte della famiglia di librerie tidyverse:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUna tabella può essere indicizzata per riga e per colonna come una matrice, ma è possibile anche attingere alle colonne come vettori usando il nome:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nE, ovviamente, per ottenere i numeri la cui radice è dispari:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#la-gestione-dei-dati-data-mangling",
    "href": "r_brief.html#la-gestione-dei-dati-data-mangling",
    "title": "R minimo",
    "section": "4.1 La gestione dei dati (data mangling)",
    "text": "4.1 La gestione dei dati (data mangling)\nLa libreria tidyverse mette a disposizione tutto ciò che serve per maneggiare tabelle di dati in maniera molto completa, sintetica e efficiente.\nPer rendere il codice più leggibile, anziché nidificare le chiamate ad una serie di funzioni si preferisce utilizzare l’operatore pipe, %&gt;%, che passa il risultato di una funzione come primo argomento della successiva:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nche equivale a scrivere:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nma è più leggibile, soprattutto se si va a capo dopo ogni pipe, in modo che ad ogni riga corrisponda un passo dell’algoritmo.\nLe funzioni di data mangling più comuni sono:\n\nmutate(), per modificare o aggiungere una o più colonne\nfilter(), per filtrare la tabella selezionando solo alcune righe\nselect(), per selezionare solo alcune colonne\narrange(), per riordinare le righe\n\nAd esempio:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSi noti che tutte queste funzioni sono non distruttive, cioè non alterano la tabella di partenza ma ne restituiscono una nuova. Se il risultato è utile per successive operazioni, quindi, è necessario salvarlo, ad esempio con:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLe funzioni group_by() e summarise() servono per operare su gruppi di righe; ad esempio, per calcolare il massimo di B e la media di C per le righe in cui A è pari o dispari:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page."
  },
  {
    "objectID": "r_brief.html#i-grafici",
    "href": "r_brief.html#i-grafici",
    "title": "R minimo",
    "section": "4.2 I grafici",
    "text": "4.2 I grafici\ntidyverse ha messo a disposizione la libreria ggplot2, che consente di creare grafici per layer. Ogni layer rappresenta una geometria, ed è una funzione che comincia generalmente con geom_; i vari layer si sommano con un +. Il grafico comincia con ggplot(), che serve a caricare la tabella di dati e predisporre lo spazio del grafico stesso.\nLa funzione aes()infine rappresenta l’estetica, cioè stabilisce quali variabili (cioè colonne della tabella) vanno sui vari assi del grafico. Qui per assi si intendono sia gli assi cartesiani che gli assi generalizzati, cioè colori, dimensione, tipo linea, ecc. utilizzati per rappresentare le varie serie.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNel caso di più assi si passa l’estetica più generale a ggplot(), quelle particolari alle successive geometrie. In questo caso, solo per geom_point() si sono specificate le estetiche per coloer e dimensione del punto, entrambe collegate alla colonna C.\nSi noti che nelle estetiche è possibile anche applicare trasformazioni:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSerie differenti possono essere identificate per colore (o per tipo linea, o per larghezza linea, ecc.):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn questi casi però è preferibile usare l’approccio tidy : la tabella originale deve contenere una osservazione per riga, una variabile per colonna. La tabella t non è tidy, perché una stessa riga ha più di una osservazione (per A, B e C).\nPer rendere la tabella tidy:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ndove pivot_longer(-A, ...) significa “riorganizza tutte le colonne meno la colonna A”, dopodiché i nomi delle colonne vanno a finire nella colonna series, i valori nella colonna value.\nUna tabella tidy è più semplice da mettere in grafico (e più efficiente da manipolare):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCome si vede, si ottiene gratuitamente la legenda. Più serie possono essere separate contemporaneamente per colore, tipo di linea, larghezza di linea, trasparenza, ecc."
  },
  {
    "objectID": "r_brief.html#map",
    "href": "r_brief.html#map",
    "title": "R minimo",
    "section": "5.1 Map",
    "text": "5.1 Map\nle funzioni di purrr che cominciano con map_* operano su una lista o un vettore, ritornando una collezione di uguale dimensione e del tipo specificato. Ad esempio, map_dbl() restituisce una lista di double, map_chr() una lista di stringhe, ecc. Il primo argomento (spesso passato via pipe) è la collezione, il secondo è una funzione, eventualmente creata sul posto:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPer brevità si può scrivere anche:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\ne addirittura, sostituendo \\(x) con ~ e x con .:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTutti questi esempi in realtà possono essere evitati scrivendo semplicemente LETERS[1:10], ma le funzioni map_*() risultano indispensabili quando non esiste una equivalente funzione vettorializzata."
  },
  {
    "objectID": "r_brief.html#reduce",
    "href": "r_brief.html#reduce",
    "title": "R minimo",
    "section": "5.2 Reduce",
    "text": "5.2 Reduce\nL’algoritmo reduce applica una mappa alla collezione e accumula ogni elemento in un accumulatore. In R si ottiene mediante la funzione purrr::reduce():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nPiù in breve:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn questo caso, il valore iniziale dell’accumulatore è il primo elemento della collezione e il loop inizia a partire dal secondo. Quando invece l’accumulatore deve essere di un tipo differente dagli elementi, è necessario inizializzarlo con il parametro .init. È il caso, ad esempio, se voglio accumulare gli elementi in una lista:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nin cui l’accumulatore è inizialmente una lista vuota (list()) alla quale aggiungo di volta in volta 2 elevato a ogni elemento del vettore iniziale (1:4), con il nome pari alla i-esima lettera minuscola (con offset 1, letters[elem + 1]). A differenza degli esempi precedenti, questo non è semplificabile con una funzione vettorializzata."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Misure Industriali",
    "section": "",
    "text": "Contenuti del corso:\n\nR in breve (un’introduzione veramente breve al linguaggio R)\nFast Fourier Transform\nFiltri\n\nMateriale aggiuntivo:\n\nDispensa 2023"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html",
    "title": "Filtri",
    "section": "",
    "text": "# FUNZIONE: Bodeplot\nggbodeplot &lt;- function(tf, fmin=1, fmax=1e4, df=0.01) {\n  # vector of points for each order of magnitude (OOM):\n  pts &lt;- 10^seq(0, 1, df) %&gt;% tail(-1)\n  # vector of OOMs:\n  ooms &lt;- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  # combine pts and ooms:\n  freqs &lt;- as.vector(pts %o% ooms)\n  # warning: bode wants pulsation!\n  bode(tf, freqs*2*pi) %&gt;% {\n    tibble(f=.$w/(2*pi), `magnitude (dB)`=.$mag, `phase (deg)`=.$phase)} %&gt;%\n    pivot_longer(-f) %&gt;% \n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(\n      minor_breaks=scales::minor_breaks_n(10), \n      labels= ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"frequency (Hz)\")\n}\n\n# FUNZIONE: Generazione segnale sinusoidale con diverse armoniche\nsignal &lt;- function(t, pars, rad = FALSE) { \n  stopifnot(is.data.frame(pars))\n  with(pars, {\n    if (!rad) {\n      phi &lt;- phi/180*pi\n      f &lt;- 2*pi*f\n    }\n    map_dbl(t, \\(t) sum( map_vec(seq_along(w) , \\(i) w[i]*cos(t*f[i] + phi[i] ))))\n  })\n}\n\n\n\n\nDefiniamo un segnale d’ingresso (nel caso di sistemi di misura si tratta di un misurando) costituito da segnali armonici, più un eventuale disturbo normale:\n\nf0 &lt;- 10\n\n# Provare con un'armonica pura\n# pars &lt;- tibble(\n#   w = c(1),\n#   f = c(f0),  # 1 funziona\n#   phi = c(0)\n# )\n\n# Provare con tante armoniche\npars &lt;- tibble(\n  w = c(1, 0.1, 0.3),\n  f = c(15, 20, 45),\n  phi = c(0, 0, 0)\n)\n\nNt &lt;- 1000 # numero totale dei campioni\ns &lt;- tibble(\n  t = 0:Nt * 0.001, # 1 kHz di frequenza di campionamento\n  u = signal(t, pars), \n  un = u + rnorm(length(t), 0, pars$w[1] / 10)\n)\n\nLa trasformata di Fourier mostra i picchi attesi:\n\ns %&gt;% \n  mutate(\n    f = 0:(n()-1)/max(t),\n    fft_u = fft(un),\n    intensity_u = Mod(fft_u) / n()*2,\n    phase_u = Arg(fft_u)/pi*180\n  ) %&gt;% \n  slice_head(n=as.integer(nrow(.)/2)) %&gt;%\n  ggplot(aes(x=f, y=intensity_u)) +\n  geom_spoke(aes(y=0, radius=intensity_u, angle=pi/2)) +\n  geom_point()\n\n\n\n\nFFT del segnale armonico di riferimento\n\n\n\n\n\n\n\nCon il metodo delle impedenze generalizzate si ottiene:\n\\[\nH(i\\omega)=\\frac{V_\\mathrm{out}(i\\omega)}{V_\\mathrm{in}(i\\omega)}=\\frac{C i\\omega + K}{M (i\\omega)^2 + C i\\omega + K}\n\\tag{1}\\]\nLa frequenza naturale del sistema è \\(f_0=\\frac{1}{2\\pi}\\sqrt{\\frac{K}{M}}\\), e l’attenuazione comincia a \\(\\sqrt{2}f_0\\).\nPossiamo definire la funzione di trasferimento in Equazione 1 con la funzione control::tf(), che prende come due argomenti due vettori con i coefficienti della Equazione 1, in ordine decrescente di grado della variabile \\(i\\omega\\):\n\nM &lt;- 10\nK &lt;- 1000\nC &lt;- 50\n\n# Frequenza naturale:\nfn &lt;- 1/(2*pi) * sqrt(K/M)\n\nnum &lt;- c(C, K)\nden &lt;- c(M, C, K)\n\nH &lt;- tf(num, den)\n\nggbodeplot(H, fmin=0.1, fmax=100) +\n  geom_vline(xintercept=c(1, sqrt(2)) * fn, color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(fn, 2), \"Hz\",\n    \" - Isolation: &gt;\", round(sqrt(2)*fn, 2), \"Hz\"))\n\nRegistered S3 methods overwritten by 'signal':\n  method         from   \n  print.freqs    gsignal\n  print.freqz    gsignal\n  print.grpdelay gsignal\n  plot.grpdelay  gsignal\n  print.impz     gsignal\n  print.specgram gsignal\n  plot.specgram  gsignal\n\n\n\n\n\nBode plot per il sistema di isolamento da vibrazioni\n\n\n\n\n\ncat(\"Per la frequenza\", f0, \"Hz abbiamo: \\nModulo:\", Mod(freqresp(H, 2*pi*f0)), \"\\nFase:\", Arg(freqresp(H, 2*pi*f0))*180/pi, \"°\\n\")\n\nPer la frequenza 10 Hz abbiamo: \nModulo: 0.08539786 \nFase: -102.9892 °\n\n\n\n\n\n\n\n\nVersione alternativa\n\n\n\nO anche, usando glue, è più semplice comporre delle stringe inserendo tra graffe le espressioni da valutare:\n\nglue(\"Per la frequenza {f0} Hz abbiamo: \\nModulo: {Mod(freqresp(H, 2*pi*f0)) %&gt;% round(3)}\\nFase: {(Arg(freqresp(H, 2*pi*f0))*180/pi) %&gt;% round(3)}°\")\n\nPer la frequenza 10 Hz abbiamo: \nModulo: 0.085\nFase: -102.989°\n\n\n\n\nDunque, se inseriamo un’armonica a fase nulla come un coseno \\(\\cos(\\omega_{0} t)\\) di frequenza pari a 10 Hz avremo in uscita la stessa armonica attenuata di 0.085 e sfasata di 103°. Dovrebbe comportarsi effettivamente come un sistema di isolamento delle vibrazioni.\n\n\n\nAndiamo a verificarlo. Simuliamo cosa succede in uscita se imponiamo il segnale al sistema d’isolamento impiegando il simulatore integrato in R lsim().\n\noutput &lt;- lsim(H, s$un, s$t)\ns &lt;- s %&gt;% \n  mutate(\n    # Simulazione dell'uscita\n    y = output$y[1,]\n  )\n\n# Grafici\npp &lt;- plot_ly() %&gt;%\n  add_lines(s$t, s$y, name = \"output\", line= list(color= \"red\")) %&gt;%\n  add_lines(s$t, s$un, name = \"input\", line= list(color= \"blue\")) %&gt;%\n  layout(title = \"Input & Output\")\npp\n\n\n\n\n\n\n\n\n\n\n\nVersione alternativa\n\n\n\nAttenzione: i grafici che usano plotly sono oggetti Javascript e in quanto tali non sono compatibili con LaTeX, quindi non è possibile generare anche la versione pdf se il documento contiene grafici plotly.\n\n(s %&gt;% \n  select(t, input=y, output=un) %&gt;% \n  pivot_longer(-t, names_to = \"segnale\", values_to = \"valore\") %&gt;% \n  ggplot(aes(x=t, y=valore, color=segnale)) +\n  geom_line()) %&gt;% \n  ggplotly()\n\n\n\n\n\n\n\nSe avete usato come parametro frequenza della funzione creata 10 Hz potete verificare come il segnale in uscita si sia effettivamente attenuato di parecchio!\n\n\n\n\n\n\nNota\n\n\n\n# DA FARE: Stimare il segnale in ingresso originale a partire dal segnale in uscita e dal modulo e la fase della funzione di trasferimento\nNOTA: impiegare funzioni che processano automaticamente tutte le armoniche che sono presenti nel segnale. In altre parole impiegare nelle funzioni che costruirete la struttura della funzione signal()\n# SUGGERIMENTI:\n\ncalcolare FFT\ntrovare i picchi FFT\napplicare inversa di modulo e fase della funz trasferimento alle armoniche corrispondenti ai picchi del modulo della FFT\nscrivere una funzione che stima l’ingresso da generiche componenti armoniche in uscita che avrete salvato in un contenitore dati ‘picchi’ ed H(w): signal_input &lt;- function(t, picchi, H) {}\nquando il vostro codice funziona provate ad aggiungere altre armoniche\nquando il vostro codice funziona provate ad aggiungere rumore"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#funzioni",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#funzioni",
    "title": "Filtri",
    "section": "",
    "text": "# FUNZIONE: Bodeplot\nggbodeplot &lt;- function(tf, fmin=1, fmax=1e4, df=0.01) {\n  # vector of points for each order of magnitude (OOM):\n  pts &lt;- 10^seq(0, 1, df) %&gt;% tail(-1)\n  # vector of OOMs:\n  ooms &lt;- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  # combine pts and ooms:\n  freqs &lt;- as.vector(pts %o% ooms)\n  # warning: bode wants pulsation!\n  bode(tf, freqs*2*pi) %&gt;% {\n    tibble(f=.$w/(2*pi), `magnitude (dB)`=.$mag, `phase (deg)`=.$phase)} %&gt;%\n    pivot_longer(-f) %&gt;% \n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(\n      minor_breaks=scales::minor_breaks_n(10), \n      labels= ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"frequency (Hz)\")\n}\n\n# FUNZIONE: Generazione segnale sinusoidale con diverse armoniche\nsignal &lt;- function(t, pars, rad = FALSE) { \n  stopifnot(is.data.frame(pars))\n  with(pars, {\n    if (!rad) {\n      phi &lt;- phi/180*pi\n      f &lt;- 2*pi*f\n    }\n    map_dbl(t, \\(t) sum( map_vec(seq_along(w) , \\(i) w[i]*cos(t*f[i] + phi[i] ))))\n  })\n}"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#segnale-in-ingresso",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#segnale-in-ingresso",
    "title": "Filtri",
    "section": "",
    "text": "Definiamo un segnale d’ingresso (nel caso di sistemi di misura si tratta di un misurando) costituito da segnali armonici, più un eventuale disturbo normale:\n\nf0 &lt;- 10\n\n# Provare con un'armonica pura\n# pars &lt;- tibble(\n#   w = c(1),\n#   f = c(f0),  # 1 funziona\n#   phi = c(0)\n# )\n\n# Provare con tante armoniche\npars &lt;- tibble(\n  w = c(1, 0.1, 0.3),\n  f = c(15, 20, 45),\n  phi = c(0, 0, 0)\n)\n\nNt &lt;- 1000 # numero totale dei campioni\ns &lt;- tibble(\n  t = 0:Nt * 0.001, # 1 kHz di frequenza di campionamento\n  u = signal(t, pars), \n  un = u + rnorm(length(t), 0, pars$w[1] / 10)\n)\n\nLa trasformata di Fourier mostra i picchi attesi:\n\ns %&gt;% \n  mutate(\n    f = 0:(n()-1)/max(t),\n    fft_u = fft(un),\n    intensity_u = Mod(fft_u) / n()*2,\n    phase_u = Arg(fft_u)/pi*180\n  ) %&gt;% \n  slice_head(n=as.integer(nrow(.)/2)) %&gt;%\n  ggplot(aes(x=f, y=intensity_u)) +\n  geom_spoke(aes(y=0, radius=intensity_u, angle=pi/2)) +\n  geom_point()\n\n\n\n\nFFT del segnale armonico di riferimento"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#impieghiamo-un-sistema-per-isolamento-da-vibrazioni-per-simulare-luscita",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#impieghiamo-un-sistema-per-isolamento-da-vibrazioni-per-simulare-luscita",
    "title": "Filtri",
    "section": "",
    "text": "Con il metodo delle impedenze generalizzate si ottiene:\n\\[\nH(i\\omega)=\\frac{V_\\mathrm{out}(i\\omega)}{V_\\mathrm{in}(i\\omega)}=\\frac{C i\\omega + K}{M (i\\omega)^2 + C i\\omega + K}\n\\tag{1}\\]\nLa frequenza naturale del sistema è \\(f_0=\\frac{1}{2\\pi}\\sqrt{\\frac{K}{M}}\\), e l’attenuazione comincia a \\(\\sqrt{2}f_0\\).\nPossiamo definire la funzione di trasferimento in Equazione 1 con la funzione control::tf(), che prende come due argomenti due vettori con i coefficienti della Equazione 1, in ordine decrescente di grado della variabile \\(i\\omega\\):\n\nM &lt;- 10\nK &lt;- 1000\nC &lt;- 50\n\n# Frequenza naturale:\nfn &lt;- 1/(2*pi) * sqrt(K/M)\n\nnum &lt;- c(C, K)\nden &lt;- c(M, C, K)\n\nH &lt;- tf(num, den)\n\nggbodeplot(H, fmin=0.1, fmax=100) +\n  geom_vline(xintercept=c(1, sqrt(2)) * fn, color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(fn, 2), \"Hz\",\n    \" - Isolation: &gt;\", round(sqrt(2)*fn, 2), \"Hz\"))\n\nRegistered S3 methods overwritten by 'signal':\n  method         from   \n  print.freqs    gsignal\n  print.freqz    gsignal\n  print.grpdelay gsignal\n  plot.grpdelay  gsignal\n  print.impz     gsignal\n  print.specgram gsignal\n  plot.specgram  gsignal\n\n\n\n\n\nBode plot per il sistema di isolamento da vibrazioni\n\n\n\n\n\ncat(\"Per la frequenza\", f0, \"Hz abbiamo: \\nModulo:\", Mod(freqresp(H, 2*pi*f0)), \"\\nFase:\", Arg(freqresp(H, 2*pi*f0))*180/pi, \"°\\n\")\n\nPer la frequenza 10 Hz abbiamo: \nModulo: 0.08539786 \nFase: -102.9892 °\n\n\n\n\n\n\n\n\nVersione alternativa\n\n\n\nO anche, usando glue, è più semplice comporre delle stringe inserendo tra graffe le espressioni da valutare:\n\nglue(\"Per la frequenza {f0} Hz abbiamo: \\nModulo: {Mod(freqresp(H, 2*pi*f0)) %&gt;% round(3)}\\nFase: {(Arg(freqresp(H, 2*pi*f0))*180/pi) %&gt;% round(3)}°\")\n\nPer la frequenza 10 Hz abbiamo: \nModulo: 0.085\nFase: -102.989°\n\n\n\n\nDunque, se inseriamo un’armonica a fase nulla come un coseno \\(\\cos(\\omega_{0} t)\\) di frequenza pari a 10 Hz avremo in uscita la stessa armonica attenuata di 0.085 e sfasata di 103°. Dovrebbe comportarsi effettivamente come un sistema di isolamento delle vibrazioni."
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#simulazione-uscita",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#simulazione-uscita",
    "title": "Filtri",
    "section": "",
    "text": "Andiamo a verificarlo. Simuliamo cosa succede in uscita se imponiamo il segnale al sistema d’isolamento impiegando il simulatore integrato in R lsim().\n\noutput &lt;- lsim(H, s$un, s$t)\ns &lt;- s %&gt;% \n  mutate(\n    # Simulazione dell'uscita\n    y = output$y[1,]\n  )\n\n# Grafici\npp &lt;- plot_ly() %&gt;%\n  add_lines(s$t, s$y, name = \"output\", line= list(color= \"red\")) %&gt;%\n  add_lines(s$t, s$un, name = \"input\", line= list(color= \"blue\")) %&gt;%\n  layout(title = \"Input & Output\")\npp\n\n\n\n\n\n\n\n\n\n\n\nVersione alternativa\n\n\n\nAttenzione: i grafici che usano plotly sono oggetti Javascript e in quanto tali non sono compatibili con LaTeX, quindi non è possibile generare anche la versione pdf se il documento contiene grafici plotly.\n\n(s %&gt;% \n  select(t, input=y, output=un) %&gt;% \n  pivot_longer(-t, names_to = \"segnale\", values_to = \"valore\") %&gt;% \n  ggplot(aes(x=t, y=valore, color=segnale)) +\n  geom_line()) %&gt;% \n  ggplotly()\n\n\n\n\n\n\n\nSe avete usato come parametro frequenza della funzione creata 10 Hz potete verificare come il segnale in uscita si sia effettivamente attenuato di parecchio!\n\n\n\n\n\n\nNota\n\n\n\n# DA FARE: Stimare il segnale in ingresso originale a partire dal segnale in uscita e dal modulo e la fase della funzione di trasferimento\nNOTA: impiegare funzioni che processano automaticamente tutte le armoniche che sono presenti nel segnale. In altre parole impiegare nelle funzioni che costruirete la struttura della funzione signal()\n# SUGGERIMENTI:\n\ncalcolare FFT\ntrovare i picchi FFT\napplicare inversa di modulo e fase della funz trasferimento alle armoniche corrispondenti ai picchi del modulo della FFT\nscrivere una funzione che stima l’ingresso da generiche componenti armoniche in uscita che avrete salvato in un contenitore dati ‘picchi’ ed H(w): signal_input &lt;- function(t, picchi, H) {}\nquando il vostro codice funziona provate ad aggiungere altre armoniche\nquando il vostro codice funziona provate ad aggiungere rumore"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#funzioni-da-costruire",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#funzioni-da-costruire",
    "title": "Filtri",
    "section": "2.1 Funzioni da costruire",
    "text": "2.1 Funzioni da costruire\n\n# FUNZIONE: calcola il modulo di una funzione di trasferimento\n# w è la pulsazione in radianti\n# num e den numeratore e denominatore in ordine di esponente decrescente\nvalore_H &lt;- function(num, den, w) { \n  sum(map_vec(seq_along(num) , \\(n) rev(num)[n]*(1i*w)^(n-1) )) / sum(map_vec(seq_along(den) , \\(n) rev(den)[n]*(1i*w)^(n-1) ))  \n}\n\n\n# FUNZIONE: Stima ingresso da componenti armoniche in uscita 'picchi' ed H(w)\nsignal_input &lt;- function(t, picchi, H) { \n    map_dbl(t, \\(t) sum( map_vec(seq_len(nrow(picchi)) , \\(i) picchi[i,1] / Mod(valore_H(num, den, picchi[i,2])) * cos( picchi[i,2]*t + picchi[i, 3] - Arg(valore_H(num, den, picchi[i,2])) ))))\n}"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#calcoliamo-fft-ed-i-suoi-picchi",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#calcoliamo-fft-ed-i-suoi-picchi",
    "title": "Filtri",
    "section": "2.2 Calcoliamo FFT ed i suoi picchi",
    "text": "2.2 Calcoliamo FFT ed i suoi picchi\n\n# Aggiungiamo l'FFT\ns &lt;- s %&gt;% \n  mutate(\n    f = 0:(length(t)-1)/max(t),\n    fft_y = fft(y - mean(y)),\n    intensity_y = Mod(fft_y) / n()*2,\n    phase_y = Arg(fft_y)/pi*180\n  )\n\nplot_ly() %&gt;%\n  add_lines(x = s$f, y = s$intensity_y, type = \"bar\", name = \"FFT uscita\", marker = list(color= \"red\"))  %&gt;%\n  layout(title = \"Modulo FFT Output\")\n\nA marker object has been specified, but markers is not in the mode\nAdding markers to the mode...\n\n\n\n\n\nplot_ly() %&gt;%\n  add_lines(x = s$f, y = s$phase_y, type = \"bar\", name = \"FFT uscita\", marker = list(color= \"red\")) %&gt;%\n  layout(title = \"Fase FFT Output [°]\")\n\nA marker object has been specified, but markers is not in the mode\nAdding markers to the mode...\n\n\n\n\n\n# Troviamo i primi N picchi del modulo della FFT\nN &lt;- length(pars$f)\npicchi &lt;- matrix(0, nrow = N, ncol = 3)  # Inizializza la matrice dei picchi\npeaks &lt;- findpeaks(s$intensity_y[1:(length(s$intensity_y) %/% 2)], nups = 1, ndowns = 1, sortstr = TRUE)\n\n# Controlla che ci siano picchi previsti\nif (!is.null(peaks) && nrow(peaks) &gt;= N) {\n  picchi_values &lt;- peaks[1:N, 1]  # Valori dei picchi\n  picchi_indices &lt;- peaks[1:N, 2] # Indici dei picchi\n  picchi_freq &lt;- s$f[picchi_indices]  # Frequenze corrispondenti ai picchi\n  picchi_fasi &lt;- s$phase_y[picchi_indices] # Fasi corrispondenti ai picchi\n\n  # Assegna i valori alla matrice picchi\n  picchi[, 1] &lt;- picchi_values\n  picchi[, 2] &lt;- 2 * pi * picchi_freq\n  picchi[, 3] &lt;- pi * picchi_fasi / 180\n}\nprint(picchi)\n\n            [,1]       [,2]      [,3]\n[1,] 0.055242299  94.247780 -1.723821\n[2,] 0.007827489   6.283185 -1.592151\n[3,] 0.005242204 282.743339 -1.620200\n\n\n\n\n\n\n\n\nVersione alternativa\n\n\n\n\n(s %&gt;% \n  select(f, intensity=intensity_y, phase=phase_y) %&gt;% \n  pivot_longer(-f) %&gt;% \n  ggplot(aes(x=f, y=value)) + \n  geom_line(linewidth=0.2) + \n  geom_point(size=0.5, color=\"red\") +\n  facet_wrap(~name, nrow=2, scales=\"free\")) %&gt;% \n  ggplotly()"
  },
  {
    "objectID": "esercizi/4_3_Inv_armoniche_pure v2.html#applichiamo-inversa-della-funz-trasferimento",
    "href": "esercizi/4_3_Inv_armoniche_pure v2.html#applichiamo-inversa-della-funz-trasferimento",
    "title": "Filtri",
    "section": "2.3 Applichiamo inversa della funz trasferimento",
    "text": "2.3 Applichiamo inversa della funz trasferimento\n\n# Applichiamo inversa della funz trasferimento ai picchi della FFT in modo da stimare l'ingresso a partire dall'uscita\ns &lt;- s %&gt;% \n  mutate(\n    u_est = signal_input(t, picchi, H)\n  )\n\npp %&gt;%\n  add_lines(s$t, s$u_est, name = \"input stimato\", line= list(color= \"green\")) %&gt;%\n  layout(title = \"Input originario e stimato\")\n\n\n\n\n\n\n\n\n\n\n\nVersione alternativa\n\n\n\n\ns %&gt;% \n  select(t, y, un, u_est) %&gt;% \n  pivot_longer(-t) %&gt;% \n  ggplot(aes(x=t, y=value, color=name)) +\n  geom_line() +\n  xlim(c(0, 0.4))"
  },
  {
    "objectID": "esercizi/4_Compensazione_dinamica.html",
    "href": "esercizi/4_Compensazione_dinamica.html",
    "title": "3. Compensazione (o Misura) dinamica",
    "section": "",
    "text": "1 Librerie\nQuanto segue richiede questi pacchetti:\n\nlibrary(plotly)\nlibrary(tidyverse)\nlibrary(signal)\nlibrary(gsignal)\nlibrary(control)\nlibrary(latex2exp)\n\n\n\n2 Funzioni di utilità\nPer comodità definiamo alcune funzioni di utilità:\nBode plot mediante GGplot:\n\n# FUNZIONE: Bodeplot\nggbodeplot &lt;- function(tf, fmin=1, fmax=1e4, df=0.01) {\n  # vector of points for each order of magnitude (OOM):\n  pts &lt;- 10^seq(0, 1, df) %&gt;% tail(-1)\n  # vector of OOMs:\n  ooms &lt;- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  # combine pts and ooms:\n  freqs &lt;- as.vector(pts %o% ooms)\n  # warning: bode wants pulsation!\n  bode(tf, freqs*2*pi) %&gt;% {\n    tibble(f=.$w/(2*pi), `magnitude (dB)`=.$mag, `phase (deg)`=.$phase)} %&gt;%\n    pivot_longer(-f) %&gt;% \n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(\n      minor_breaks=scales::minor_breaks_n(10), \n      labels= ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"frequency (Hz)\")\n}\n\nGenerazione di un segnale sinusoidale con diverse armoniche, come definite in una tabella (pars) con le colonne w (ampiezza), f (frequenza) e phi (fase) per le varie frequenze (una riga per ogni armonica):\n\nsignal &lt;- function(t, pars, rad = FALSE) { \n  stopifnot(is.data.frame(pars))\n  with(pars, {\n    if (!rad) {\n      phi &lt;- phi/180*pi\n      f &lt;- 2*pi*f\n    }\n    map_dbl(t, \\(t) sum( map_vec(seq_along(w) , \\(i) w[i]*sin(t*f[i] + phi[i] ))))\n  })\n}\n\n\n\n3 Simuliamo l’uscita di un sistema di misura\n\n# Parametri del misurando (input del sistema di misura)\npars &lt;- tibble(\n  w = c(1, 0.3, 0.3), \n  f = c(1/30, 1/10, 1/4), \n  phi = c(0, 0, 0)\n)\n\n# Generiamo il misurando u\n# Specifica il tempo di campionamento:\nTs &lt;- 0.01  \nu &lt;- tibble(\n  t = 0:10000 * Ts,\n  u = signal(t, pars),\n  un = u + rnorm(length(t), 0, pars$w[1]/10)\n)\n\n# Definiamo la Funzione di Trasferimento dello strumento:\n# Coefficienti del numeratore e denominatore\nnum &lt;- c(5, 1)   # 5s + 1\nden &lt;- c(1, 2, 1) # s^2 + 2s + 1\nH &lt;- tf(num, den)\nprint(H)\n\n\ny1:\n    5 s^1 + 1 \n  - - - - - - - - - -\n     s^2 + 2 s + 1 \n\n\nTransfer Function: Continuous time model \n\n# Diagramma di Bode\nggbodeplot(H, fmin=0.01, fmax=1e2, df=1/max(u$t))\n\n\n\n\n\n\n\n\n\n(u %&gt;% \n  mutate(\n    out = lsim(H, un, t)$y[1,],\n    ideal = lsim(H, u, t)$y[1,],\n  ) %&gt;% \n  pivot_longer(c(un, out, ideal), names_to = \"series\") %&gt;% \n  ggplot(aes(x=t, y=value, color=series)) + \n  geom_line()) %&gt;% \n  ggplotly()\n\n\n\n\n\n\n# Simulazione dell'uscita con rumore\noutput &lt;- lsim(H, u$un, u$t)\n\n# Simulazione dell'uscita ideale\noutputI &lt;- lsim(H, u$u, u$t)\nyI &lt;- outputI$y[1,]\n\n# Grafici\npp &lt;- plot_ly() %&gt;%\n  add_lines(u$t, output$y, name = \"output\", line= list(color= \"red\")) %&gt;%\n  add_lines(u$t, u$un, name = \"misurando\", line= list(color= \"blue\")) %&gt;%\n  add_lines(u$t, yI, name = \"output ideale\", line= list(color= \"green\"))\n# pp\n\nSi nota come un rumore ‘bianco’, ovvero contenente tutte le armoniche, viene ridotto in uscita dal sistema di misura che si comporta in modo simile ad un passa-basso.\n\n\n4 Stima del misurando a partire dal segnale in uscita\nSe vogliamo invece stimare il misurando a partire dal segnale in uscita invertendo quindi la funzione di trasferimento, condizione che si verifica per le misure ‘dinamiche’ (per le statiche ricordate si inverte la caratteristica statica che si ottiene dopo taratura, statica). In questo caso, cosa succederà a parità di rumore bianco in uscita?\n\n# Segnale in uscita con rumore\nyn = yI + rnorm(length(u$t), 0, pars$w[1]/10)\n\n\n# Ricaviamo l'inversa della Funzione di Trasferimento:\nHinv &lt;- tf(den, num)\n\n[1] \"TFCHK: Transfer function may not be proper and may lead to errors. Num &gt; Den\"\n\nprint(Hinv)\n\n\ny1:\n     s^2 + 2 s + 1 \n  - - - - - - - - - -\n    5 s^1 + 1 \n\nTransfer Function: Continuous time model \n\n# Diagramma di Bode\nggbodeplot(Hinv, fmin=0.01, fmax=1e2, df=1/max(u$t))\n\n\n\n\n\n\n\n# SCOMMENTARE:\n# # Simulazione dell'ingresso\n# input &lt;- lsim(Hinv, yn, y$t, x0 = rep(0, length(pole(Hinv))))\n# \n# # Grafici dell'ingresso e dell'uscita\n# pp &lt;- plot_ly() %&gt;%\n#   add_lines(y$t, y$yn, name = \"output\", line= list(color= \"blue\")) %&gt;%\n#   add_lines(y$t, input$y, name = \"Estimated input\", line= list(color= \"red\"))\n# pp\n\nOtteniamo l’errore: “The order of the Numerator should be equal or lesser than the Denominator” Dunque R si rifiuta di impiegare la funzione di trasferimento inversa. Perchè? Trovare una soluzione e svilupparla continuando il codice fornito.\n\n\n5 OMETTERE E FAR FARE COME ESERCIZIO\nCambiamo strategia: Aggiungiamo un filtro in serie all’inversa della Funzione di Trasferimento:\n\n# Aggiungiamo un filtro in serie all'inversa della Funzione di Trasferimento:\n# Coefficienti del numeratore e denominatore\nnumf &lt;- c(1)   # 5s + 1\nfreqT &lt;- 100   # 1 ... 100 se alto è come se non ci fosse\ndenf &lt;- c(1/freqT, 1) # s^2 + 2s + 1\nHf &lt;- tf(numf, denf)\nprint(Hf)\n\n\ny1:\n            1 \n  - - - - - - - - -\n    0.01 s^1 + 1 \n\n\nTransfer Function: Continuous time model \n\n# Diagramma di Bode\nggbodeplot(Hf, fmin=0.01, fmax=1e2, df=1/max(u$t))\n\n\n\n\n\n\n\nHinv_filt &lt;- series(Hinv, Hf)  # Collegamento in serie\n\n[1] \"TFCHK: Transfer function may not be proper and may lead to errors. Num &gt; Den\"\n\nprint(Hinv_filt)\n\n\ny1:\n         s^2 + 2 s + 1 \n  - - - - - - - - - - - - -\n    0.05 s^2 + 5.01 s + 1 \n\n\nTransfer Function: Continuous time model \n\n# Diagramma di Bode\nggbodeplot(Hinv_filt, fmin=0.01, fmax=1e2, df=1/max(u$t))\n\n\n\n\n\n\n\n# Simulazione dell'ingresso a partire dall'uscita per ottenere il misurando\ninput &lt;- lsim(Hinv_filt, yn, u$t, x0 = rep(0, length(pole(Hinv_filt))))\n\n# Grafici\npp &lt;- plot_ly() %&gt;%\n  add_lines(u$t, input$y, name = \"misurando stimato\", line= list(color= \"red\")) %&gt;%\n  add_lines(u$t, yn, name = \"output con rumore\", line= list(color= \"blue\"))%&gt;%\n  add_lines(u$t, u$u, name = \"misurando originario\", line= list(color= \"green\"))\npp\n\n\n\n\n\nSUGGERIMENTI: - provare a cambiare la frequenza di taglio del filtro\n……….\nCambiamo strategia: operiamo nel dominio della frequenza andando a calcolare la trasformata dell’ingresso che sarà data dalla moltiplicazione della trasformata dell’uscita per la funzione di trasferimento inversa:"
  },
  {
    "objectID": "filtri.html",
    "href": "filtri.html",
    "title": "Filtri",
    "section": "",
    "text": "Un sistema dinamico lineare per il quale esiste una funzione di trasferimento sinusoidale può rappresentare diverse cose:\n\nun elemento che elabora segnali: la funzione di trasferimento non è utile solo per la soluzione di equazioni differenziali che divengo semplici equazioni algebriche, ma anche per effettuare elaborazioni sulle componenti armoniche di un generico segnale e prevedere quali armoniche conterrà l’uscita in base al suo diagramma di Bode. Tali blocchi di elaborazione possono servire per ridurre il rumore in alta frequenza (filtri passa basso), quello in bassa (filtri passa alto), etc;\nuno strumento di misura: la funzione di trasferimento in questo caso descrive come lo strumento modifica le componenti armoniche di un segnale da misurare (misurando) e prevedere quali armoniche conterrà l’uscita dello strumento in base al suo diagramma di Bode. Va da sé che uno strumento ideale dovrebbe far passare tutte le armoniche del misurando inalterate. Ovvero né alterate in ampiezza e neppure sfasate. In questo modo esiste una corrispondenza esatta (a meno di un fattore di conversione proporzionale) tra uscita e misurando in ingresso. Questo a volte è possibile, a volte no. Come vedremo, se uno strumento è particolarmente ‘lento’, esso distorcerà significativamente le ampiezze e sfaserà altrettanto significativamente le fasi delle componenti armoniche tanto più si va su in frequenza. In questi casi, per stimare correttamente il misurando, occorre invertire la funzione di trasferimento in una procedura analoga a quella vista per l’operazione di misura di una grandezza statica. Questa procedura può essere definita Compensazione Dinamica che vedremo in uno dei prossimi paragrafi.\n\n\n\nSi consideri il segnale ed il modulo del suo spettro mostrate in Figura 1 (una misura di temperatura tramite PT100 su di una piastra termostatata che regola la temperatura tra due valori soglia). Se il segnale viene posto in ingresso ad un sistema che possiede una funzione di trasferimento passa basso, si ottiene un segnale in uscita con le medesime componenti in bassa frequenza mentre quelle in alta sono attenuate.\n\n\n\n\n\n\nFigura 1: Rappresentazione ingresso-uscita di un sistema dinamico regolato da equazione differenziale lineare.\n\n\n\n\n\n\n\n\n\nFigura 2: Schema a blocchi di un processo di riduzione delle componenti in alta frequenza. In altre parole filtraggio in alta frequenza mediante un passa-basso. Nella figura sono rappresentati i segnali d’ingresso ed uscita in funzione del tempo ed il modulo (fase omessa) del loro spettro e la funzione di trasferimento che ha elaborato l’ingresso in modulo e fase.\n\n\n\nÈ possibile notare che il segnale in uscita non mostra più il rumore originario in alta frequenza in quanto la funzione di trasferimento ha attenuato proprio le componenti armoniche ad alta frequenza che non appartenevano ad un andamento di temperatura. La dinamica termica è infatti generalmente ‘lenta’. Appartenevano, ad esempio, al rumore elettromagnetico di natura interferente.\nLe tipologie di filtri sono dette\n\npassa-basso nel caso in cui vengano mantenute le componenti a bassa frequenza ed eliminate quelle ad lata frequenza;\npassa-alto nel caso contrario;\npassa-banda nel caso in cui vengano lasciate immutate le componenti appartenenti ad una data frequenza ed eliminate le altre;\nelimina-banda nel caso opposto.\n\nL’ordine del filtro coincide con l’ordine del sistema lineare corrispondente al filtro e definisce, nel diagramma di Bode, la pendenza di modulo(espresso nel diagramma logaritmico in decibel per decade) ed andamento della fase. Altro parametro importante è la frequenza di taglio \\(f_c\\) definita come quella frequenza alla quale il segnale viene distorto in modo trascurabile, quindi:\n\nla massima attenuazione (o amplificazione) della potenza delle armoniche è pari al 50%, ovvero l’ampiezza viene attenuata di un fattore uno su radice di due, in termini logaritmici quindi \\(\\pm 3\\) dB;\nlo sfasamento è pressoché lineare (introducendo eventualmente un ritardo ma non una distorsione). A tale conclusione si arriva considerando la proprietà dell’anticipo-ritardo della trasformata.\n\nAlla frequenza di taglio corrisponde implicitamente una banda passante che sarà da 0 ad \\(f_c\\) nel caso di passa basso, da \\(f_c\\) ad infinito nel caso di passa alto."
  },
  {
    "objectID": "filtri.html#esempio-di-riduzione-del-rumore-in-alta-frequenza-su-di-un-segnale-di-temperatura",
    "href": "filtri.html#esempio-di-riduzione-del-rumore-in-alta-frequenza-su-di-un-segnale-di-temperatura",
    "title": "Filtri",
    "section": "",
    "text": "Si consideri il segnale ed il modulo del suo spettro mostrate in Figura 1 (una misura di temperatura tramite PT100 su di una piastra termostatata che regola la temperatura tra due valori soglia). Se il segnale viene posto in ingresso ad un sistema che possiede una funzione di trasferimento passa basso, si ottiene un segnale in uscita con le medesime componenti in bassa frequenza mentre quelle in alta sono attenuate.\n\n\n\n\n\n\nFigura 1: Rappresentazione ingresso-uscita di un sistema dinamico regolato da equazione differenziale lineare.\n\n\n\n\n\n\n\n\n\nFigura 2: Schema a blocchi di un processo di riduzione delle componenti in alta frequenza. In altre parole filtraggio in alta frequenza mediante un passa-basso. Nella figura sono rappresentati i segnali d’ingresso ed uscita in funzione del tempo ed il modulo (fase omessa) del loro spettro e la funzione di trasferimento che ha elaborato l’ingresso in modulo e fase.\n\n\n\nÈ possibile notare che il segnale in uscita non mostra più il rumore originario in alta frequenza in quanto la funzione di trasferimento ha attenuato proprio le componenti armoniche ad alta frequenza che non appartenevano ad un andamento di temperatura. La dinamica termica è infatti generalmente ‘lenta’. Appartenevano, ad esempio, al rumore elettromagnetico di natura interferente.\nLe tipologie di filtri sono dette\n\npassa-basso nel caso in cui vengano mantenute le componenti a bassa frequenza ed eliminate quelle ad lata frequenza;\npassa-alto nel caso contrario;\npassa-banda nel caso in cui vengano lasciate immutate le componenti appartenenti ad una data frequenza ed eliminate le altre;\nelimina-banda nel caso opposto.\n\nL’ordine del filtro coincide con l’ordine del sistema lineare corrispondente al filtro e definisce, nel diagramma di Bode, la pendenza di modulo(espresso nel diagramma logaritmico in decibel per decade) ed andamento della fase. Altro parametro importante è la frequenza di taglio \\(f_c\\) definita come quella frequenza alla quale il segnale viene distorto in modo trascurabile, quindi:\n\nla massima attenuazione (o amplificazione) della potenza delle armoniche è pari al 50%, ovvero l’ampiezza viene attenuata di un fattore uno su radice di due, in termini logaritmici quindi \\(\\pm 3\\) dB;\nlo sfasamento è pressoché lineare (introducendo eventualmente un ritardo ma non una distorsione). A tale conclusione si arriva considerando la proprietà dell’anticipo-ritardo della trasformata.\n\nAlla frequenza di taglio corrisponde implicitamente una banda passante che sarà da 0 ad \\(f_c\\) nel caso di passa basso, da \\(f_c\\) ad infinito nel caso di passa alto."
  },
  {
    "objectID": "filtri.html#esempi",
    "href": "filtri.html#esempi",
    "title": "Filtri",
    "section": "2.1 Esempi",
    "text": "2.1 Esempi\nRiutilizziamo la funzione signal():\n\nsignal &lt;- function(t, pars, rad=FALSE) {\n  stopifnot(is.data.frame(pars))\n  if (!rad) {\n    pars$phi &lt;- pars$phi/180*pi\n    pars$f &lt;- 2*pi*pars$f\n  }\n  with(\n    pars,\n    map_dbl(t, \\(t) map_vec(seq_along(w), ~ w[.]*sin(t*f[.]+phi[.])) %&gt;% sum())\n  )\n}\n\nDefiniamo una sinusoide base con due disturbi armonici, più un disturbo normale:\n\nN &lt;- 100\npars &lt;- tibble(\n  w = c(1, 0.1, 0.3),\n  f = c(1/25, 1/5, 1/3),\n  phi = c(0, 0, 0)\n)\n\nCominciamo con realizzare il grafico del segnale e delle sue componenti:\n\ns &lt;- tibble(\n  t = 0:N,\n  s = signal(t, pars[1,]),\n  y = signal(t, pars), \n  yn = y + rnorm(length(t), 0, pars$w[1] / 10)\n)\n\ns %&gt;% \n  select(t, sine=s, signal=y, `signal+noise`=yn) %&gt;% \n  pivot_longer(-t) %&gt;% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n\n\n\n\nSegnale armonico con disturbo\n\n\n\n\nLa trasformata di Fourier mostra i tre picchi attesi:\n\ns %&gt;% \n  mutate(\n    f = 0:(n()-1)/max(t),\n    fft = fft(yn),\n    intensity = Mod(fft) / n()*2,\n    phase = Arg(fft)/pi*180\n  ) %&gt;% \n  slice_head(n=as.integer(nrow(.)/2)) %&gt;%\n  ggplot(aes(x=f, y=intensity)) +\n  geom_spoke(aes(y=0, radius=intensity, angle=pi/2)) +\n  geom_point()\n\n\n\n\nFFT del segnale armonico di riferimento\n\n\n\n\nIl filtraggio online viene realizzato in due passi: prima si progetta il filtro, selezionando il tipo di filtro e i parametri che si adattano al segnale che si vuole filtrare e alla sua trasformata nel dominio delle frequenze, poi si applica il filtro al segnale.\nNel nostro caso scegliamo un filtro di tipo Butterworth di ordine 3:\n\nft &lt;- 2/pars$f[1] / (1/2)\n# Doppio della frequenza base\nfn &lt;- pars$f[1]*2\n# Frequenza di Nyquist\nfny &lt;- 1/(s$t[2] - s$t[1]) / 2\n# Frequenza di taglio\nft &lt;- fn/fny\n# Filtro Butterworth di ordine 3 con cut-off al doppio della frequenza base\n# Il parametro w è normalizzato tra 0 e 1, con 1 = fny\nflt &lt;- butter(3, w=ft)\nflt\n\n$b\n[1] 0.01018258 0.03054773 0.03054773 0.01018258\n\n$a\n[1]  1.0000000 -2.0037975  1.4470540 -0.3617959\n\nattr(,\"class\")\n[1] \"Arma\"\n\n\nCome si vede, l’oggetto filtro contiene i due vettori coi coefficienti polinomiali di un modello ARMA.\nLa funzione freqz() consente di valutare le caratteristiche del filtro:\n\n(fq &lt;- freqz(flt))\n\n\n\n\nCaratteristiche del filtro Butterworth di ordine 3\n\n\n\n\nIl grafico Stop band è lo stesso grafico Pass band ma con limiti dell’asse y più ampi, in modo da evidenziare come poco oltre 3 Hz c’è un’attenuazione completa.\nGrafici simili possono essere ottenuti in ggplot come segue, estraendo direttamente le componenti dall’oggetto restituito da freqz. Si noti che la componente fq$h va scomposta in modulo e fase; il modulo va poi convertito in decibel (dB) e la fase va “srotolata” (unwrap):\n\ntibble(\n  h = fq$h,\n  mod = 20*log10(Mod(h)),\n  phase = Arg(h) %&gt;% unwrap() / pi * 180,\n  frequency = fq$w,\n) %&gt;% {\n  (ggplot(., aes(x=frequency)) + \n     geom_line(aes(y=mod)) + \n     coord_cartesian(ylim=c(-4, 0.5)) +\n     geom_vline(xintercept=ft, color=\"red\", linetype=2) +\n     labs(y=\"Intensity (dB)\", x=\"\")) /\n  (ggplot(., aes(x=frequency)) + \n     geom_line(aes(y=phase)) +\n     geom_vline(xintercept=ft, color=\"red\", linetype=2) +\n     labs(y=\"phase (°)\", x=\"frequency (Hz)\"))\n}\n\n\n\n\nCaratteristiche del filtro Butterworth di ordine 3 (con GGplot)\n\n\n\n\nIl filtro può poi essere applicato con filter():\n\ns %&gt;% \n  mutate(\n    sflt = flt %&gt;% filter(yn)\n  ) %&gt;% \n  select(t, `signal+noise`=yn, sine=s, filtered=sflt) %&gt;% \n  pivot_longer(-t) %&gt;% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n\n\n\n\nSegnale di riferimento filtrato\n\n\n\n\nCome si vede, il filtro ripulisce sia il disturbo casuale che le armoniche con frequenza superiore alla frequenza di taglio 0.16 Hz., seppure introducendo un ritardo di fase.\nPer eliminare il ritardo, se il filtro è applicato offline, si può ricorrere a filtfilt() al posto di filter(): questa funzione applica il filtraggio in avanti e indietro, compensando quindi il ritardo:\n\ns %&gt;% \n  mutate(\n    sflt = flt %&gt;% filtfilt(yn)\n  ) %&gt;% \n  select(t, `signal+noise`=yn, sine=s, filtered=sflt) %&gt;% \n  pivot_longer(-t) %&gt;% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n\n\n\n\nSegale di riferimento filtrato in avanti e indietro, eliminando il ritardo"
  },
  {
    "objectID": "filtri.html#ricorsione",
    "href": "filtri.html#ricorsione",
    "title": "Filtri",
    "section": "2.2 Ricorsione",
    "text": "2.2 Ricorsione\nIl vantaggio dei filtri online è che possono essere calcolati direttamente durante l’acquisizione di un segnale, grazie al fatto che il filtro è esprimibile come una formula di ricorsione.\nLa funzione butter() restituisce infatti un filtro in forma dei coefficienti di un modello \\(\\mathrm{ARMA}(p, q)\\), per cui è possibile calcolare la nuova osservazione filtrata \\(y_n\\) in funzione delle precedenti osservazioni:\n\\[\na_1 y_n + a_2y_{n-1} + \\dots + a_{n_a}y_{n-p+1} = b_1x_n + b_2 x_{n-1} + \\dots + b_{n_b}x_{n-q+1}\n\\]\ndove le \\(y_i\\) sono i valori filtrati, le \\(x_i\\) i valori originari, e i due vettori A e B contengono i termini \\(a_i\\) e \\(b_i\\), con \\(a_1 = 1\\). Quindi:\n\\[\ny_n = b_1x_n + b_2 x_{n-1} + \\dots + b_{n_b}x_{n-n_b+1} - \\left(a_2y_{n-1} + \\dots + a_{n_a}y_{n-n_a+1}\\right)\n\\tag{1}\\]\nPer un filtro Butterworth di ordine \\(m\\), si ha che \\(p=q=m\\) e i vettori A e B hanno entrambi \\(m+1\\) elementi.\nÈ facile implementare la Equazione 1 in un qualsiasi linguaggio di programmazione. Ad esempio in R definiamo una funzione che prende in ingresso una tabella, una nuova osservazione e il filtro (con le componenti ARMA \\(A\\) e \\(B\\)), e restituisce la stessa tabella con una riga in più (con il nuovo campione e il valore filtrato con la Equazione 1). L’inizializzazione della formula ricorsiva viene fatta con una tabella vuota (o NA):\n\nmy_filter &lt;- function(t = NA, sample, flt) {\n  # Inizializzazione o aggiornamento tabella:\n  if (!is.data.frame(t) || nrow(t) == 0)\n    t &lt;- tibble(i=1, x=sample, y=0)\n  else\n    t &lt;- add_row(t, i = tail(t, 1)$i + 1, x=sample)\n  A &lt;- flt$a\n  B &lt;- flt$b\n  n &lt;- nrow(t)\n  nb &lt;- min(n, length(B))\n  # Termini Moving Average:\n  MA &lt;- rev(B[1:nb]) * tail(t$x, nb)\n  # Termini Auto-Regressive:\n  AR &lt;- rev(A[1:nb]) * tail(t$y, nb)\n  # Nuova osservazione filtrata:\n  t$y[n] &lt;- sum(MA) - sum(AR, na.rm=TRUE)\n  return(t)\n}\n\nIn questo modo il filtro può essere applicato un’osservazione alla volta, e per questo si chiama filtro online: può cioè essere aggiornato durante l’acquisizione del segnale, pena ovviamente un ritardo sul segnale filtrato:\n\ntibble() %&gt;% \n  my_filter(1, flt) %&gt;% \n  my_filter(2, flt) %&gt;% \n  my_filter(3, flt) %&gt;% \n  my_filter(4, flt) %&gt;% \n  my_filter(5, flt) %&gt;% \n  my_filter(5, flt) %&gt;% \n  my_filter(5, flt) %&gt;% \n  kable()\n\n\n\n\ni\nx\ny\n\n\n\n\n1\n1\n0.0101826\n\n\n2\n2\n0.0713167\n\n\n3\n3\n0.2503604\n\n\n4\n4\n0.6058080\n\n\n5\n5\n1.1625457\n\n\n6\n5\n1.8998389\n\n\n7\n5\n2.7409252\n\n\n\n\n\nUtilizziamolo sul segnale originale è più evidente il ritardo:\n\nfiltered_signal &lt;- tibble()\n\nfor (sample in s$yn) {\n  filtered_signal &lt;- my_filter(filtered_signal, sample, flt)\n}\n\nfiltered_signal %&gt;%\n  ggplot(aes(x=i)) +\n  geom_line(aes(y=y), color=\"red\") +\n  geom_line(aes(y=x))\n\n\n\n\nSegnale di riferimento filtrato con la funzione my_filter()\n\n\n\n\nSfruttando la programmazione funzionale di purrr:\n\ns$yn %&gt;% \n  reduce(\\(tbl, obs) my_filter(tbl, obs, flt), .init=tibble()) %&gt;% \n  ggplot(aes(x=i)) +\n  geom_line(aes(y=y), color=\"red\") +\n  geom_line(aes(y=x))\n\n\n\n\nSegnale di riferimento filtrato con la funzione my_filter(), usando purrr"
  },
  {
    "objectID": "filtri.html#filtri-iir-e-fir",
    "href": "filtri.html#filtri-iir-e-fir",
    "title": "Filtri",
    "section": "2.3 Filtri IIR e FIR",
    "text": "2.3 Filtri IIR e FIR\nTra i filtri online c’è un’importante differenza, che classifica filtri Infinite Impulse Response (IIR) e filtri Finite Impulse Response (FIR): considerando un impulso unitario:\n\\[\ny(x)=\\begin{cases}\n0 & x &lt; 0 \\\\\n1 & x \\geqslant 0\n\\end{cases}\n\\] le due classi di filtri si comportano come segue:\n\nIIR: sono filtri con memoria infinita: il valore filtrato dell’impulso mantiene memoria di ogni osservazione precedente e quindi non si stabilizza mai a 1 (seppure avvicinandosi sempre più). Corrispondono a filtri ARMA, in cui la parte AR ha un numero di coefficienti maggiore di uno;\nFIR: sono filtri con memoria limitata: dopo un numero di osservazioni pari alla memoria del filtro il valore filtrato è uguale a 1. Corrispondono a filtri MA (che ha memoria finita), un cui manca la parte AR (che ha memoria infinita).\n\nOsserviamo la risposta al gradino dello stesso filtro flt sopra definito:\n\ntibble(i=1:100, x=1) %&gt;% \n  mutate(xf = filter(flt, x)) %&gt;% \n  pivot_longer(-i, names_to = \"signal\") %&gt;% \n  ggplot(aes(x=i)) + \n  geom_line(aes(y=value, color=signal)) \n\n\n\n\nRisposta all’impulso di un filtro IIR\n\n\n\n\nSe osserviamo un dettaglio della parte finale (i&gt;80), possiamo verificare come in realtà il segnale filtrato non si stabilizzi mai a 1:\n\ntibble(i=1:100, x=1) %&gt;% \n  mutate(xf = filter(flt, x)) %&gt;% \n  dplyr::filter(i&gt;80) %&gt;% \n  pivot_longer(-i, names_to = \"signal\") %&gt;% \n  ggplot(aes(x=i)) + \n  geom_line(aes(y=value-1, color=signal)) +\n  scale_y_continuous(\n    n.breaks = 10,\n    labels = scales::label_scientific(digits=6)\n  )\n\n\n\n\nRisposta all’impulso di un filtro IIR (dettaglio)\n\n\n\n\n\n\nAttenzione: sia il pacchetto gsignal che dplyr (parte di tidyverse) forniscono una funzione filter(). Siccome gsignal è stato caricato dopo tidyverse, è necessario disambiguare la funzione desiderata premettendo il nome del pacchetto. Per questo motivo scriviamo dplyr::filter(i&gt;80) anziché semplicemente filter(i&gt;80).\nOra creiamo invece un filtro FIR di ordine 3, con la stessa frequenza di taglio, osservando come possa essere rappresentato da un modello MA con 4 termini (3+1):\n\n(flt_fir &lt;- fir1(3, w=ft))\n\n[1] 0.04355854 0.45644146 0.45644146 0.04355854\nattr(,\"class\")\n[1] \"Ma\"\n\n\nLe caratteristiche del filtro sono le seguenti:\n\nfreqz(flt_fir)\n\n\n\n\nCaratteristiche di un filtro FIR di ordine 3\n\n\n\n\nSi noti, in particolare, che la fase è lineare: ciò è un vantaggio perché può essere facilmente utilizzata per compensare il ritardo, come si vedrà più sotto.\nLa risposta al gradino è la seguente, notando che dopo tre osservazioni il filtro è identico al segnale:\n\ntibble(i=1:100, x=1) %&gt;% \n  mutate(xf = filter(flt_fir, x)) %&gt;% \n  pivot_longer(-i, names_to = \"signal\") %&gt;% \n  ggplot(aes(x=i)) + \n  geom_line(aes(y=value, color=signal)) \n\n\n\n\nRisposta all’impulso di un filtro FIR\n\n\n\n\nVediamo come si comporta un filtro FIR sul segnale armonico di riferimento. Anzitutto notiamo come la caratteristica del filtro FIR sia meno aggressiva del filtro IIR a parità di banda e di ordine. Pertanto utilizziamo un filtro di ordine superiore:\n\nflt_fir &lt;- fir1(6, w=ft)\ns %&gt;% \n  mutate(\n    sflt = flt_fir %&gt;% filter(yn)\n  ) %&gt;% \n  select(t, `signal+noise`=yn, sine=s, filtered=sflt) %&gt;% \n  pivot_longer(-t) %&gt;% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n\n\n\n\nSegnale di riferimento filtrato con filtro FIR\n\n\n\n\nDato che il ritardo di fase è lineare, è facile compensarlo: la funzione grpdelay() valuta il ritardo, e la funzione lead() (cioè lag() per ritardi negativi) lo compensa:\n\nflt_fir &lt;- fir1(6, w=ft)\ndelay &lt;- grpdelay(flt_fir)$gd %&gt;% mean() %&gt;% round() %&gt;% as.integer()\n\ns %&gt;% \n  mutate(\n    sflt = flt_fir %&gt;% filter(yn),\n    sflt_nd = sflt %&gt;% lead(delay)\n  ) %&gt;% \n  select(t, `signal+noise`=yn, signal=s, `filtered nd`=sflt_nd) %&gt;% \n  pivot_longer(-t) %&gt;% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n\n\n\n\nSegnale di riferimento filtrato con filtro FIR, ritardo compensato\n\n\n\n\nOvviamente, la compensazione del ritardo rende un filtro FIR offline: se così non fosse, ci consentirebbe di conoscere il futuro."
  },
  {
    "objectID": "filtri.html#stabilità",
    "href": "filtri.html#stabilità",
    "title": "Filtri",
    "section": "2.4 Stabilità",
    "text": "2.4 Stabilità\nCome abbiamo visto un filtro può essere rappresentato come un processo ARMA. In quanto tale, può presentare problemi di stabilità. Un filtro è detto stabile se la sua risposta al gradino decade a zero indefinitamente, e viceversa.\nPer verificare la stabilità di un filtro lo si converte in formato zero-pole-gain, un formato che rappresenta il filtro come radici dei polinomi al numeratore della funzione di trasferimento (zeroes) e come radici del polinomio al denominatore (poles):\n\n# poles\n1/(polyroot(flt$a)) %&gt;% zapsmall() %&gt;% rev()\n\n[1] 0.5913983+0.0000000i 0.7061996+0.3362227i 0.7061996-0.3362227i\n\n# zeroes\n1/(polyroot(flt$b)) %&gt;% zapsmall() %&gt;% rev()\n\n[1] -1+0i -1+0i -1+0i\n\n\nMediante gsignal è più semplice convertire il filtro in formato Zpg:\n\nflt %&gt;% as.Zpg()\n\n$z\n[1] -1.0000016-2.850647e-06i -1.0000016+2.850647e-06i -0.9999967+0.000000e+00i\n\n$p\n[1] 0.5913984+0.0000000i 0.7061996-0.3362227i 0.7061996+0.3362227i\n\n$g\nNULL\n\nattr(,\"class\")\n[1] \"Zpg\"\n\n\nUn filtro è stabile quando tutti i poli sono all’interno del cerchio unitario sul piano immaginario:\n\ncircle &lt;- function(r=1, x0=0, y0=0, n=100, phi = 0) {\n  tibble(\n    i = 0:n,\n    theta = i * 2*pi / n,\n    x = x0 + r*cos(theta + phi),\n    y = y0 + r*sin(theta + phi)\n  )\n}\n\nflt %&gt;% as.Zpg() %&gt;% {\n  tibble(\n    zr = Re(.$z),\n    zi = Im(.$z),\n    pr = Re(.$p),\n    pi = Im(.$p)\n  )} %&gt;% \n  ggplot() +\n  geom_point(aes(x=zr, y=zi), shape=21) +\n  geom_point(aes(x=pr, y=pi), shape=4) +\n  geom_path(data=circle(), aes(x=x, y=y), color=\"red\") +\n  coord_equal() +\n  labs(x=\"Real\", y=\"Imaginary\", title=\"Zero-Pole diagram\")\n\n\n\n\nGrafico zero-pole per fil filtro IIR"
  },
  {
    "objectID": "filtri.html#termocoppia",
    "href": "filtri.html#termocoppia",
    "title": "Filtri",
    "section": "4.1 Termocoppia",
    "text": "4.1 Termocoppia\nConsideriamo il caso di una sonda PT100 immersa repentinamente in un bagno termostatato. La temperatura della sonda raggiunge quella del bagno secondo la legge:\n\\[\nT(t) = (T_i - T_f)e^{-\\frac{t}{\\tau}} + T_f\n\\tag{2}\\]\nSappiamo che \\(T_i = 33.4\\) °C, \\(T_f = 95\\) °C e stimiamo che l’immersione inizi a \\(t_0 = 50\\) s.\n\nggplot(temp, aes(x=t, y=T)) + \n  geom_line() +\n  geom_line(aes(y=Tn), color=\"red\", linewidth=1/3) +\n  labs(x=\"tempo (s)\", y=\"temperatura (°C)\")\n\n\n\n\nAcquisizione con termocoppia PT100. In rosso la nominale\n\n\n\n\n\n4.1.1 Primo metodo: intercetta\nSecondo la Equazione 2, a \\(t=\\tau\\) si ha che \\(T(\\tau) = (T_i-T_f)e^{-1} + T_f\\), cioè:\n\\[\\begin{align}\nT_f - T(\\tau) &= (T_f - T_i)e^{-1} \\\\\n&= (95 - 33.4) \\cdot 0.368 \\\\\n&= 61.6 \\cdot 0.368 \\\\\n&=  22.661\n\\end{align}\\]\ncioè \\(T(\\tau) = 72.339\\) °C. In grafico:\n\nTtau &lt;- Tf - (Tf - Ti)*exp(-1)\n\nggplot(temp, aes(x=t, y=T)) + \n  geom_line() +\n  geom_hline(yintercept = Ttau, color=\"blue\") +\n  labs(x=\"tempo (s)\", y=\"temperatura (°C)\")\n\n\n\n\nIdentificazione della temperatura \\(T(\\tau)\\)\n\n\n\n\nCioè risulta graficamente che \\(\\tau\\) è la distanza tra l’inizio del transitorio e l’intersezione con la linea blu. Sui dati:\n\ntemp %&gt;% \n  select(t, T) %&gt;%          # solo le colonne t e T\n  mutate(t = t - 50) %&gt;%    # traslo i tempi all'inizio\n  dplyr::filter(T&lt;Ttau) %&gt;% # solo i valori &lt; Ttau\n  slice_tail(n=1) %&gt;%       # prendo solo l'ultima riga\n  knitr::kable()\n\n\n\n\nt\nT\n\n\n\n\n33.5\n71.0994\n\n\n\n\n\n\n\n4.1.2 Secondo metodo: linearizzazione\nLa Equazione 2 può essere linearizzata così:\n\\[\\begin{align}\n\\frac{T(t) -T_f}{T_i - T_f} &= e^{-\\frac{t}{\\tau}} \\\\\n\\ln\\left(\\frac{T(t) -T_f}{T_i - T_f}\\right) &= \\ln(e^{-\\frac{t}{\\tau}}) \\\\\n\\ln\\left(\\frac{T(t) -T_f}{T_i - T_f}\\right) &= -\\frac{t}{\\tau}\n\\end{align}\\]\nPosso riorganizzare i dati come segue:\n\ntemp.l &lt;- temp %&gt;% \n  select(t, T) %&gt;% \n  mutate(t = t - 50) %&gt;%\n  dplyr::filter(t&gt;0 & t &lt; 100) %&gt;% \n  mutate(y = log((T-Tf)/(Ti - Tf))) %&gt;% \n  dplyr::filter(!is.nan(y))\n\ntemp.lm &lt;- temp.l %&gt;% lm(y~t-1, data=.) \ntemp.lm %&gt;% summary()\n\n\nCall:\nlm(formula = y ~ t - 1, data = .)\n\nResiduals:\n      Min        1Q    Median        3Q       Max \n-0.254494 -0.023759 -0.004018  0.020228  0.253887 \n\nCoefficients:\n    Estimate Std. Error t value Pr(&gt;|t|)    \nt -2.975e-02  7.284e-05  -408.5   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.05925 on 198 degrees of freedom\nMultiple R-squared:  0.9988,    Adjusted R-squared:  0.9988 \nF-statistic: 1.669e+05 on 1 and 198 DF,  p-value: &lt; 2.2e-16\n\ntau &lt;- round(-1/temp.lm$coefficients, 1)\ncat(paste(\"tau:\", tau))\n\ntau: 33.6\n\n\n\ntemp.l %&gt;% \n  ggplot(aes(x=t, y=y)) +\n  geom_smooth(method=\"lm\", formula = y~x-1) +\n  geom_point(size=0.5) +\n  labs(x=\"tempo (s)\", \n       y=latex2exp::TeX(\"$\\\\log_{10}(\\\\frac{T-T_f}{T_i-T_f})$ (T in °C)\"))\n\n\n\n\nRegressione del modello dopo linearizzazione\n\n\n\n\n\n\n4.1.3 Terzo metodo: regressione non-lineare\nCon il terzo metodo si usa la regressione non-lineare ai minimi quadrati per ottenere direttamente tutti e tre i parametri \\(T_i, T_f, \\tau\\):\n\ntemp.l &lt;- temp %&gt;% \n  select(t, T) %&gt;% \n  mutate(t = t - 50) %&gt;%\n  dplyr::filter(t&gt;0) \n\nfit &lt;- nls(T~(Ti - Tf)*exp(-t/tau) + Tf, \n    data = temp.l, \n    start = list(\n      Ti=30,\n      Tf=100,\n      tau=10\n    ))\n\nfit\n\nNonlinear regression model\n  model: T ~ (Ti - Tf) * exp(-t/tau) + Tf\n   data: temp.l\n   Ti    Tf   tau \n33.58 95.00 33.65 \n residual sum-of-squares: 137.7\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 1.104e-07\n\ntemp.l %&gt;% \n  modelr::add_predictions(fit, var=\"fit\") %&gt;% \n  ggplot(aes(x=t, y=T)) + \n  geom_line() +\n  geom_line(aes(y=fit), color=\"red\", linewidth=1/4) +\n  labs(x=\"tempo (s)\", y=\"temperatura (°C)\")\n\n\n\n\n\n\n\n\nSi notino i valori iniziali approssimativi passati per i tre parametri.\nI vantaggi di questo terzo metodo sono:\n\nnon è necessario stimare soggettivamente \\(T_i\\) e \\(T_f\\), ma vengono identificati direttamente dalla regressione\ndefinendo il modello per parti (cioè costante per \\(t&lt;t_i\\)), è possibile identificare anche \\(t_i\\) (lo si lascia per esercizio)\nmediante il metodo bootstrap è possibile ottenere gli intervalli di confidenza su tutti e tre i parametri (lo si lascia per esercizio)\n\nPer contro, è computazionalmente più complesso, mentre il primo e al limite anche il secondo metodo possono essere applicati anche “a mano”.\n\n\n\n\n\n\nEsercizio\n\n\n\nDefinire una funzione piecewise costante fino a \\(T_i\\) e poi esponenziale e regredire tale funzione, identificando anche \\(T_i\\)"
  },
  {
    "objectID": "filtri.html#considerazioni-sulla-relazione-tra-costante-di-tempo-e-funzione-di-trasferimento",
    "href": "filtri.html#considerazioni-sulla-relazione-tra-costante-di-tempo-e-funzione-di-trasferimento",
    "title": "Filtri",
    "section": "4.2 Considerazioni sulla relazione tra costante di tempo e funzione di trasferimento",
    "text": "4.2 Considerazioni sulla relazione tra costante di tempo e funzione di trasferimento\n\n\n\n\n\n\nImportante\n\n\n\nMancano pagine 53-54."
  },
  {
    "objectID": "filtri.html#compensazione-o-misura-dinamica",
    "href": "filtri.html#compensazione-o-misura-dinamica",
    "title": "Filtri",
    "section": "4.3 Compensazione o misura dinamica",
    "text": "4.3 Compensazione o misura dinamica\n\n\n\n\n\n\nImportante\n\n\n\nMancano pagine 55-58."
  },
  {
    "objectID": "filtri.html#esempio-sistema-per-isolamento-da-vibrazioni.",
    "href": "filtri.html#esempio-sistema-per-isolamento-da-vibrazioni.",
    "title": "Filtri",
    "section": "6.1 Esempio: sistema per isolamento da vibrazioni.",
    "text": "6.1 Esempio: sistema per isolamento da vibrazioni.\nCon il metodo delle impedenze generalizzate si ottiene:\n\\[\nH(i\\omega)=\\frac{V_\\mathrm{out}(i\\omega)}{V_\\mathrm{in}(i\\omega)}=\\frac{C i\\omega + K}{M (i\\omega)^2 + C i\\omega + K}\n\\tag{3}\\]\nLa frequenza naturale del sistema è \\(f_0=\\frac{1}{2\\pi}\\sqrt{\\frac{K}{M}}\\), e l’attenuazione comincia a \\(\\sqrt{2}f_0\\).\nPossiamo definire la funzione di trasferimento in Equazione 3 con la funzione control::tf(), che prende come due argomenti due vettori con i coefficienti della Equazione 3, in ordine decrescente di grado della variabile \\(i\\omega\\):\n\nM &lt;- 10\nK &lt;- 1000\nC &lt;- 50\n\n# Frequenza naturale:\nf0 &lt;- 1/(2*pi) * sqrt(K/M)\n\ntf(c(C, K),c(M, C, K)) %&gt;% \n  ggbodeplot(fmin=0.1, fmax=100) +\n  geom_vline(xintercept=c(1, sqrt(2)) * f0, color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(f0, 2), \"Hz\", \n    \" - Isolation: &gt;\", round(sqrt(2)*f0, 2), \"Hz\"))\n\n\n\n\nBode plot per il sistema di isolamento da vibrazioni\n\n\n\n\n\n\nDecibel — La magnitudine della funzione di trasferimento è espressa in decibel (dB). Un decibel corrisponde a \\(10 \\log_{10}(X)\\). Tuttavia è d’uso scalare la magnitudine in modo che rappresenti il rapporto tra le potenze, che dipende dal quadrato della variabile in oggetto. Quindi l’effettiva relazione diventa \\(20 \\log_{10}(X)\\).\nIn altre parole, un rapporto pari a 1:10 sulla variabile corrisponde a 1:100 sulla potenza; quindi se esprimo la magnitudine come \\(20 \\log_{10}(X)\\) significa che un’attenuazione di -10 dB\\(_{20}\\) sul segnale corrisponde a -10 dB\\(_{10}\\) sulla potenza. Ancora più chiaramente: -20 dB sulla magnitudine significa un’attenuazione di 10 volte sul segnale, 100 volte sulla potenza.\n\nSi noti che lo stesso risultato si ottiene a partire dalle equazioni della dinamica del sistema, effettuando la trasformata di Laplace \\(\\mathcal{L}\\):\n\\[\\begin{align}\nM\\ddot y + C\\dot y + Ky &= C\\dot x + K x \\\\\n&\\downarrow \\mathcal{L}\\left(\\frac{\\mathrm{d}^nx}{\\mathrm{d}t^n}\\right) = s^n X(s) \\\\\nM s^2 Y(s) + C s Y(s) + K Y(s) &= CsX(s) + KX(s)\n\\end{align}\\]\ndalla quale otteniamo l’espressione per la funzione di trasferimento:\n\\[\nH(s) = \\frac{Y(s)}{X(s)} = \\frac{Cs + K}{Ms^2 + Cs  + K }\n\\] che corrisponde alla Equazione 3 a meno della sostituzione \\(s=i\\omega\\)."
  },
  {
    "objectID": "filtri.html#esempio-accoppiamento-rotativo-motore-carico.",
    "href": "filtri.html#esempio-accoppiamento-rotativo-motore-carico.",
    "title": "Filtri",
    "section": "6.2 Esempio: accoppiamento rotativo motore-carico.",
    "text": "6.2 Esempio: accoppiamento rotativo motore-carico.\nCon il metodo delle impedenze generalizzate si ottiene:\n\\[\nH(i\\omega) = \\frac{1}{I_c (i\\omega)^2 + Ci\\omega + K} = \\frac{1}{I_c/K (i\\omega)^2 + C/K i\\omega + 1}\n\\]\nLa frequenza naturale può essere ottenuta con la funzione control::damp(), campo omega:\n\nIc &lt;-  10e-3\nK &lt;-  5000\nC &lt;-  1\n\nH &lt;- tf(1,c(Ic/K, C/K, 1)) \nH.d &lt;- damp(H, doPrint=FALSE)\n\nH %&gt;% \n  ggbodeplot(fmin=10, fmax=1e4) +\n  geom_vline(xintercept=c(1, sqrt(2)) * H.d$omega[1]/(2*pi), color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(f0, 2), \"Hz\", \n    \" - Isolation: &gt;\", round(sqrt(2)*f0, 2), \"Hz\"))\n\n\n\n\nBode plot per l’accoppiamento rotativo"
  }
]