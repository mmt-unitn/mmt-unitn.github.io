{
  "hash": "67ab68f2da82c4aa0caee47eb3260c39",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Filtri\"\nauthor: \"Paolo Bosetti\"\ndate: \"2025-02-21\"\nformat: \n  html:\n    toc: TRUE\n  pdf:\n    toc: TRUE\nengine: knitr\n---\n\n\n\n\n\n\n\n\n\n# Impiego della Funzione di trasferimento per l’elaborazione dei segnali: Filtraggio in frequenza\nUn sistema dinamico lineare per il quale esiste una funzione di trasferimento sinusoidale può rappresentare diverse cose:\n\n* **un elemento che elabora segnali**: la funzione di trasferimento non è utile solo per la soluzione di equazioni differenziali che divengo semplici equazioni algebriche, ma anche per effettuare elaborazioni sulle componenti armoniche di un generico segnale e prevedere quali armoniche conterrà l’uscita in base al suo diagramma di Bode. Tali blocchi di elaborazione possono servire per ridurre il rumore in alta frequenza (filtri passa basso), quello in bassa (filtri passa alto), etc;\n* **uno strumento di misura**: la funzione di trasferimento in questo caso descrive come lo strumento modifica le componenti armoniche di un segnale da misurare (misurando) e prevedere quali armoniche conterrà l’uscita dello strumento in base al suo diagramma di Bode. Va da sé che uno strumento ideale dovrebbe far passare tutte le armoniche del misurando inalterate. Ovvero né alterate in ampiezza e neppure sfasate. In questo modo esiste una corrispondenza esatta (a meno di un fattore di conversione proporzionale) tra uscita e misurando in ingresso. Questo a volte è possibile, a volte no. Come vedremo, se uno strumento è particolarmente 'lento', esso distorcerà significativamente le ampiezze e sfaserà altrettanto significativamente le fasi delle componenti armoniche tanto più si va su in frequenza. In questi casi, per stimare correttamente il misurando, occorre invertire la funzione di trasferimento in una procedura analoga a quella vista per l’operazione di misura di una grandezza statica. Questa procedura può essere definita **Compensazione Dinamica** che vedremo in uno dei prossimi paragrafi.\n\n## Esempio di riduzione del rumore in alta frequenza su di un segnale di temperatura\n\nSi consideri il segnale ed il modulo del suo spettro mostrate in figura 2.5 (una misura di temperatura tramite PT100 su di una piastra termostatata che regola la temperatura tra due valori soglia). Se il segnale viene posto in ingresso ad un sistema che possiede una funzione di trasferimento passa basso, si ottiene un segnale in uscita con le medesime componenti in bassa frequenza mentre quelle in alta sono attenuate.\n\n![Schema a blocchi di un processo di riduzione delle componenti in alta frequenza. In altre parole filtraggio in alta frequenza mediante un passa-basso. Nella figura sono rappresentati i segnali d’ingresso ed uscita in funzione del tempo ed il modulo (fase omessa) del loro spettro e la funzione di trasferimento che ha elaborato l’ingresso in modulo e fase.](images/fig-pt100.png){#fig-pt100}\n\nÈ possibile notare che il segnale in uscita non mostra più il rumore originario in alta frequenza in quanto la funzione di trasferimento ha attenuato proprio le componenti armoniche ad alta frequenza che non appartenevano ad un andamento di temperatura. La dinamica termica è infatti generalmente 'lenta'. Appartenevano, ad esempio, al rumore elettromagnetico di natura interferente.\n\nLe tipologie di filtri sono dette\n\n* **passa-basso** nel caso in cui vengano mantenute le componenti a bassa frequenza ed eliminate quelle ad lata frequenza; \n* **passa-alto** nel caso contrario; \n* **passa-banda** nel caso in cui vengano lasciate immutate le componenti appartenenti ad una data frequenza ed eliminate le altre; \n* **elimina-banda** nel caso opposto. \n\nL’**ordine del filtro** coincide con l’ordine del sistema lineare corrispondente al filtro e definisce, nel diagramma di Bode, la pendenza di modulo(espresso nel diagramma logaritmico in decibel per decade) ed andamento della fase. Altro parametro importante è la frequenza di taglio $f_c$ definita come quella frequenza alla quale il segnale viene distorto in modo trascurabile, quindi:\n\n* la massima attenuazione (o amplificazione) della potenza delle armoniche è pari al 50%, ovvero l’ampiezza viene attenuata di un fattore uno su radice di due, in termini logaritmici quindi $\\pm 3$ dB;\n* lo sfasamento è pressoché lineare (introducendo eventualmente un ritardo ma non una distorsione). A tale conclusione si arriva considerando la proprietà dell’anticipo-ritardo della trasformata. \n\nAlla frequenza di taglio corrisponde implicitamente una banda passante che sarà da 0 ad $f_c$ nel caso di passa basso, da $f_c$ ad infinito nel caso di passa alto.\n\n# Filtri online\n\nIl filtro online opera direttamente sul segnale temporale elaborandolo mano mano che esso si presenta, campione dopo campione tramite una successione per ricorrenza. \nLa dimostrazione del fatto che un sistema reale si comporta nel dominio discreto come una successione per ricorrenza la si ottiene:\n\n* moltiplicando la trasformata di un segnale d’ingresso per la funzione di trasferimento\n* antitrasformando \n* discretizzando la derivata \n\nProviamo quanto detto con un filtro del primo ordine avente uno zero ed un polo:\n\n![](images/fig-filtro-online.png){height=\"100px\"}\n\nSappiamo che:\n$$\nY(\\omega) = \\frac{1+i\\omega\\tau_N}{1+i\\omega\\tau_D}U(\\omega)\n$$\nda cui:\n$$\nY(\\omega)(1+i\\omega\\tau_D) = U(\\omega)(1+i\\omega\\tau_N)\n$$\nquindi:\n$$\nY(\\omega)+i\\omega\\tau_DY(\\omega)=U(\\omega)+i\\omega\\tau_nU(\\omega)\n$$\n\nAnti-trasformando otteniamo:\n$$\ny(t) + \\dot y(t)\\tau_D=u(t)+\\dot u(t)\\tau_N\n$$\ne applicando la formula di Eulero per la discretizzazione (anche conosciuta come formula alle differenze finite):\n$$\ny_k+\\frac{y_k-y_{k-1}}{T_c}\\tau_D=u_k\\frac{u_k-u_{k-1}}{T_c}\\tau_n\n$$\ne, in definitiva:\n$$\ny_k\\left(1+\\frac{\\tau_D}{T_c}\\right) = y_{k-1}\\frac{\\tau_D}{T_c}+ u_k\\left(1+\\frac{\\tau_N}{T_c}\\right) - u_{k-1}\\frac{\\tau_N}{T_c}\n$$\nche, normalizzando, diventa la seguente ricorrenza:\n$$\ny_k=y_{k-1}\\frac{\\tau_D/T_c}{1+\\tau_D/T_c} + u_k\\frac{\\tau_N/T_c}{1+\\tau_D/T_c}+u_{k-1}\\frac{\\tau_N/T_c}{1+\\tau_D/T_c}\n$$\n\n**Che significato assumono in R i vettori `A` e `B`?**\n\nSe $n_a$ è l'ordine del denominatore ed $n_b$ è l'ordine del numeratore, $A = [A(1), A(2),\\dots, A(n_a+1)]$, $B = [B(1), B(2),\\dots, B(n_b+1)]$:\n$$\n\\begin{aligned}\na(1)y(n) =& b(1)x(n) + b(2)x(n-1) + \\dots + b(n_b+1)x(n-n_b) + \\\\\n&- a(2)y(n-1)-\\dots-a(n_a+1)y(n-n_a)\n\\end{aligned}\n$$\n\nGrazie alla normalizzazione, si impone $a(1)=1$\n\nNel caso sopra citato della funzione di trasferimento con un polo ed uno zero del primo ordine i vettori A e B sono:\n$$\n\\begin{aligned}\nA &= \\left[ 1\\quad -\\frac{\\tau_D/T_c}{1+\\tau_D/T_c}\\right] \\\\\nB &= \\left[ \\frac{1+\\tau_N/T_c}{1+\\tau_D/T_c} \\quad -\\frac{\\tau_N/T_c}{1+\\tau_D/T_c}\\right]\n\\end{aligned}\n$$\n\nNotare che essendo $n_a = n_b = 1$ entrambi i vettori hanno 2 elementi.\n\nIn R il comando `butter(n, fn)` restituisce i coefficienti della funzione di trasferimento di un filtro Butterworth digitale passa basso di ordine $n$ in grado di operare in tempo reale con frequenza di taglio normalizzata alla frequenza di Nyquist $f_n$.\n\nLa frequenza di taglio per filtri digitali, ovvero filtri che elaborano sequenze di segnali campionati e convertiti viene solitamente normalizzata per la frequenza di Nyquist. Il motivo è semplice: un vettore corrispondente ad un segnale digitale non possiede esplicitamente informazioni circa la frequenza di campionamento per cui ha senso normalizzare il suo massimo contenuto in frequenza (ponendo quindi la fn pari ad 1) ed esprimendo i parametri di elaborazione (quali ad esempio il filtraggio) rispetto a tale valore, quindi tra 0 ed 1.\n\nSi noti come, perdendo l’informazione circa la frequenza o tempo di campionamento è possibile ragionare equivalentemente in termini di numeri di campioni. Per la frequenza di Nyquist ad esempio l’armonica corrispondente ha 2 campioni: $f_c = 1 / 1$ campione, quindi $f_n = fc / 2 = 1 / 2$ campioni, ovvero periodo 2 campioni.\n\n## Esempi\n\nRiutilizziamo la funzione `signal()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsignal <- function(t, pars, rad=FALSE) {\n  stopifnot(is.data.frame(pars))\n  if (!rad) {\n    pars$phi <- pars$phi/180*pi\n    pars$f <- 2*pi*pars$f\n  }\n  with(\n    pars,\n    map_dbl(t, \\(t) map_vec(seq_along(w), ~ w[.]*sin(t*f[.]+phi[.])) %>% sum())\n  )\n}\n```\n:::\n\n\n\n\n\n\nDefiniamo una sinusoide base con due disturbi armonici, più un disturbo normale:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN <- 100\npars <- tibble(\n  w = c(1, 0.1, 0.3),\n  f = c(1/25, 1/5, 1/3),\n  phi = c(0, 0, 0)\n)\n```\n:::\n\n\n\n\n\n\nCominciamo con realizzare il grafico del segnale e delle sue componenti:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns <- tibble(\n  t = 0:N,\n  s = signal(t, pars[1,]),\n  y = signal(t, pars), \n  yn = y + rnorm(length(t), 0, pars$w[1] / 10)\n)\n\ns %>% \n  select(t, sine=s, signal=y, `signal+noise`=yn) %>% \n  pivot_longer(-t) %>% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n```\n\n::: {.cell-output-display}\n![Segnale armonico con disturbo](filtri_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nLa trasformata di Fourier mostra i tre picchi attesi:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns %>% \n  mutate(\n    f = 0:(n()-1)/max(t),\n    fft = fft(yn),\n    intensity = Mod(fft) / n()*2,\n    phase = Arg(fft)/pi*180\n  ) %>% \n  slice_head(n=as.integer(nrow(.)/2)) %>%\n  ggplot(aes(x=f, y=intensity)) +\n  geom_spoke(aes(y=0, radius=intensity, angle=pi/2)) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![FFT del segnale armonico di riferimento](filtri_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nIl filtraggio online viene realizzato in due passi: prima si **progetta il filtro**, selezionando il tipo di filtro e i parametri che si adattano al segnale che si vuole filtrare e alla sua trasformata nel dominio delle frequenze, poi si applica il filtro al segnale.\n\nNel nostro caso scegliamo un filtro di tipo *Butterworth* di ordine 3:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nft <- 2/pars$f[1] / (1/2)\n# Doppio della frequenza base\nfn <- pars$f[1]*2\n# Frequenza di Nyquist\nfny <- 1/(s$t[2] - s$t[1]) / 2\n# Frequenza di taglio\nft <- fn/fny\n# Filtro Butterworth di ordine 3 con cut-off al doppio della frequenza base\n# Il parametro w è normalizzato tra 0 e 1, con 1 = fny\nflt <- butter(3, w=ft)\nflt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$b\n[1] 0.01018258 0.03054773 0.03054773 0.01018258\n\n$a\n[1]  1.0000000 -2.0037975  1.4470540 -0.3617959\n\nattr(,\"class\")\n[1] \"Arma\"\n```\n\n\n:::\n:::\n\n\n\n\n\nCome si vede, l'oggetto filtro contiene i due vettori coi coefficienti polinomiali di un modello ARMA.\n\nLa funzione `freqz()` consente di valutare le caratteristiche del filtro:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(fq <- freqz(flt))\n```\n\n::: {.cell-output-display}\n![Caratteristiche del filtro Butterworth di ordine 3](filtri_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nIl grafico *Stop band* è lo stesso grafico *Pass band* ma con limiti dell'asse y più ampi, in modo da evidenziare come poco oltre 3 Hz c'è un'attenuazione completa.\n\nGrafici simili possono essere ottenuti in `ggplot` come segue, estraendo direttamente le componenti dall'oggetto restituito da `freqz`. Si noti che la componente `fq$h` va scomposta in modulo e fase; il modulo va poi convertito in decibel (dB) e la fase va \"srotolata\" (`unwrap`):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  h = fq$h,\n  mod = 20*log10(Mod(h)),\n  phase = Arg(h) %>% unwrap() / pi * 180,\n  frequency = fq$w,\n) %>% {\n  (ggplot(., aes(x=frequency)) + \n     geom_line(aes(y=mod)) + \n     coord_cartesian(ylim=c(-4, 0.5)) +\n     geom_vline(xintercept=ft, color=\"red\", linetype=2) +\n     labs(y=\"Intensity (dB)\", x=\"\")) /\n  (ggplot(., aes(x=frequency)) + \n     geom_line(aes(y=phase)) +\n     geom_vline(xintercept=ft, color=\"red\", linetype=2) +\n     labs(y=\"phase (°)\", x=\"frequency (Hz)\"))\n}\n```\n\n::: {.cell-output-display}\n![Caratteristiche del filtro Butterworth di ordine 3 (con GGplot)](filtri_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\nIl filtro può poi essere applicato con `filter()`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns %>% \n  mutate(\n    sflt = flt %>% filter(yn)\n  ) %>% \n  select(t, `signal+noise`=yn, sine=s, filtered=sflt) %>% \n  pivot_longer(-t) %>% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n```\n\n::: {.cell-output-display}\n![Segnale di riferimento filtrato](filtri_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nCome si vede, il filtro ripulisce sia il disturbo casuale che le armoniche con frequenza superiore alla frequenza di taglio 0.16 Hz., seppure **introducendo un ritardo di fase**.\n\nPer eliminare il ritardo, se il filtro è applicato **offline**, si può ricorrere a `filtfilt()` al posto di `filter()`: questa funzione applica il filtraggio in avanti e indietro, compensando quindi il ritardo:\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns %>% \n  mutate(\n    sflt = flt %>% filtfilt(yn)\n  ) %>% \n  select(t, `signal+noise`=yn, sine=s, filtered=sflt) %>% \n  pivot_longer(-t) %>% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n```\n\n::: {.cell-output-display}\n![Segale di riferimento filtrato in avanti e indietro, eliminando il ritardo](filtri_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Ricorsione\n\nIl vantaggio dei filtri online è che possono essere calcolati direttamente durante l'acquisizione di un segnale, grazie al fatto che il filtro è esprimibile come una formula di ricorsione.\n\nLa funzione `butter()` restituisce infatti un filtro in forma dei coefficienti di un modello $\\mathrm{ARMA}(p, q)$, per cui è possibile calcolare la nuova osservazione filtrata $y_n$ in funzione delle precedenti osservazioni:\n\n$$\na_1 y_n + a_2y_{n-1} + \\dots + a_{n_a}y_{n-p+1} = b_1x_n + b_2 x_{n-1} + \\dots + b_{n_b}x_{n-q+1}\n$$\n\ndove le $y_i$ sono i valori filtrati, le $x_i$ i valori originari, e i due vettori `A` e `B` contengono i termini $a_i$ e $b_i$, con $a_1 = 1$. Quindi:\n\n$$\ny_n = b_1x_n + b_2 x_{n-1} + \\dots + b_{n_b}x_{n-n_b+1} - \\left(a_2y_{n-1} + \\dots + a_{n_a}y_{n-n_a+1}\\right)\n$$ {#eq-IIR}\n\nPer un filtro Butterworth di ordine $m$, si ha che $p=q=m$ e i vettori `A` e `B` hanno entrambi $m+1$ elementi.\n\nÈ facile implementare la @eq-IIR in un qualsiasi linguaggio di programmazione. Ad esempio in R definiamo una funzione che prende in ingresso una tabella, una nuova osservazione e il filtro (con le componenti ARMA $A$ e $B$), e restituisce la stessa tabella con una riga in più (con il nuovo campione e il valore filtrato con la @eq-IIR). L'inizializzazione della formula ricorsiva viene fatta con una tabella vuota (o `NA`):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_filter <- function(t = NA, sample, flt) {\n  # Inizializzazione o aggiornamento tabella:\n  if (!is.data.frame(t) || nrow(t) == 0)\n    t <- tibble(i=1, x=sample, y=0)\n  else\n    t <- add_row(t, i = tail(t, 1)$i + 1, x=sample)\n  A <- flt$a\n  B <- flt$b\n  n <- nrow(t)\n  nb <- min(n, length(B))\n  # Termini Moving Average:\n  MA <- rev(B[1:nb]) * tail(t$x, nb)\n  # Termini Auto-Regressive:\n  AR <- rev(A[1:nb]) * tail(t$y, nb)\n  # Nuova osservazione filtrata:\n  t$y[n] <- sum(MA) - sum(AR, na.rm=TRUE)\n  return(t)\n}\n```\n:::\n\n\n\n\n\n\nIn questo modo il filtro può essere applicato **un'osservazione alla volta**, e per questo si chiama *filtro online*: può cioè essere aggiornato durante l'acquisizione del segnale, pena ovviamente un ritardo sul segnale filtrato:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble() %>% \n  my_filter(1, flt) %>% \n  my_filter(2, flt) %>% \n  my_filter(3, flt) %>% \n  my_filter(4, flt) %>% \n  my_filter(5, flt) %>% \n  my_filter(5, flt) %>% \n  my_filter(5, flt) %>% \n  kable()\n```\n\n::: {.cell-output-display}\n\n\n|  i|  x|         y|\n|--:|--:|---------:|\n|  1|  1| 0.0101826|\n|  2|  2| 0.0713167|\n|  3|  3| 0.2503604|\n|  4|  4| 0.6058080|\n|  5|  5| 1.1625457|\n|  6|  5| 1.8998389|\n|  7|  5| 2.7409252|\n\n\n:::\n:::\n\n\n\n\n\n\nUtilizziamolo sul segnale originale è più evidente il ritardo:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfiltered_signal <- tibble()\n\nfor (sample in s$yn) {\n  filtered_signal <- my_filter(filtered_signal, sample, flt)\n}\n\nfiltered_signal %>%\n  ggplot(aes(x=i)) +\n  geom_line(aes(y=y), color=\"red\") +\n  geom_line(aes(y=x))\n```\n\n::: {.cell-output-display}\n![Segnale di riferimento filtrato con la funzione `my_filter()`](filtri_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nSfruttando la programmazione funzionale di `purrr`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns$yn %>% \n  reduce(\\(tbl, obs) my_filter(tbl, obs, flt), .init=tibble()) %>% \n  ggplot(aes(x=i)) +\n  geom_line(aes(y=y), color=\"red\") +\n  geom_line(aes(y=x))\n```\n\n::: {.cell-output-display}\n![Segnale di riferimento filtrato con la funzione `my_filter()`, usando `purrr`](filtri_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Filtri IIR e FIR\n\nTra i filtri online c'è un'importante differenza, che classifica filtri *Infinite Impulse Response (IIR)* e filtri *Finite Impulse Response (FIR)*: considerando un impulso unitario:\n\n$$\ny(x)=\\begin{cases}\n0 & x < 0 \\\\\n1 & x \\geqslant 0\n\\end{cases}\n$$\nle due classi di filtri si comportano come segue:\n\n- **IIR**: sono filtri con memoria infinita: il valore filtrato dell'impulso mantiene memoria di ogni osservazione precedente e quindi non si stabilizza mai a 1 (seppure avvicinandosi sempre più). Corrispondono a **filtri ARMA**, in cui la parte AR ha un numero di coefficienti maggiore di uno;\n- **FIR**: sono filtri con memoria limitata: dopo un numero di osservazioni pari alla memoria del filtro il valore filtrato è uguale a 1. Corrispondono a **filtri MA** (che ha memoria **finita**), un cui manca la parte AR (che ha memoria **infinita**).\n\nOsserviamo la risposta al gradino dello stesso filtro `flt` sopra definito:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(i=1:100, x=1) %>% \n  mutate(xf = filter(flt, x)) %>% \n  pivot_longer(-i, names_to = \"signal\") %>% \n  ggplot(aes(x=i)) + \n  geom_line(aes(y=value, color=signal)) \n```\n\n::: {.cell-output-display}\n![Risposta all'impulso di un filtro **IIR**](filtri_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nSe osserviamo un dettaglio della parte finale (`i>80`), possiamo verificare come in realtà il segnale filtrato non si stabilizzi mai a 1:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(i=1:100, x=1) %>% \n  mutate(xf = filter(flt, x)) %>% \n  dplyr::filter(i>80) %>% \n  pivot_longer(-i, names_to = \"signal\") %>% \n  ggplot(aes(x=i)) + \n  geom_line(aes(y=value-1, color=signal)) +\n  scale_y_continuous(\n    n.breaks = 10,\n    labels = scales::label_scientific(digits=6)\n  )\n```\n\n::: {.cell-output-display}\n![Risposta all'impulso di un filtro **IIR** (dettaglio)](filtri_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n::: {.content-visible when-format=\"html\"}\n:::column-margin\n**Attenzione**: sia il pacchetto `gsignal` che `dplyr` (parte di `tidyverse`) forniscono una funzione `filter()`. Siccome `gsignal` è stato caricato **dopo** `tidyverse`, è necessario disambiguare la funzione desiderata premettendo il nome del pacchetto. Per questo motivo scriviamo `dplyr::filter(i>80)` anziché semplicemente `filter(i>80)`.\n:::\n:::\n\n\nOra creiamo invece un filtro FIR di ordine 3, con la stessa frequenza di taglio, osservando come possa essere rappresentato da un modello MA con 4 termini (3+1):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(flt_fir <- fir1(3, w=ft))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.04355854 0.45644146 0.45644146 0.04355854\nattr(,\"class\")\n[1] \"Ma\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nLe caratteristiche del filtro sono le seguenti:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfreqz(flt_fir)\n```\n\n::: {.cell-output-display}\n![Caratteristiche di un filtro FIR di ordine 3](filtri_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nSi noti, in particolare, che la fase è lineare: ciò è un vantaggio perché può essere facilmente utilizzata per **compensare il ritardo**, come si vedrà più sotto.\n\nLa risposta al gradino è la seguente, notando che dopo tre osservazioni il filtro è identico al segnale:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(i=1:100, x=1) %>% \n  mutate(xf = filter(flt_fir, x)) %>% \n  pivot_longer(-i, names_to = \"signal\") %>% \n  ggplot(aes(x=i)) + \n  geom_line(aes(y=value, color=signal)) \n```\n\n::: {.cell-output-display}\n![Risposta all'impulso di un filtro **FIR**](filtri_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nVediamo come si comporta un filtro FIR sul segnale armonico di riferimento. Anzitutto notiamo come la caratteristica del filtro FIR sia meno aggressiva del filtro IIR a parità di banda e di ordine. Pertanto utilizziamo un filtro di ordine superiore:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflt_fir <- fir1(6, w=ft)\ns %>% \n  mutate(\n    sflt = flt_fir %>% filter(yn)\n  ) %>% \n  select(t, `signal+noise`=yn, sine=s, filtered=sflt) %>% \n  pivot_longer(-t) %>% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n```\n\n::: {.cell-output-display}\n![Segnale di riferimento filtrato con filtro FIR](filtri_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nDato che il ritardo di fase è lineare, è facile compensarlo: la funzione `grpdelay()` valuta il ritardo, e la funzione `lead()` (cioè `lag()` per ritardi negativi) lo compensa:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflt_fir <- fir1(6, w=ft)\ndelay <- grpdelay(flt_fir)$gd %>% mean() %>% round() %>% as.integer()\n\ns %>% \n  mutate(\n    sflt = flt_fir %>% filter(yn),\n    sflt_nd = sflt %>% lead(delay)\n  ) %>% \n  select(t, `signal+noise`=yn, signal=s, `filtered nd`=sflt_nd) %>% \n  pivot_longer(-t) %>% \n  ggplot(aes(x=t, y=value)) + \n  geom_line(aes(color=name)) +\n  labs(x=\"time (s)\")\n```\n\n::: {.cell-output-display}\n![Segnale di riferimento filtrato con filtro FIR, ritardo compensato](filtri_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nOvviamente, la compensazione del ritardo rende un filtro FIR **offline**: se così non fosse, ci consentirebbe di conoscere il futuro.\n\n## Stabilità\n\nCome abbiamo visto un filtro può essere rappresentato come un processo ARMA. In quanto tale, può presentare problemi di stabilità. Un filtro è detto **stabile** se la sua risposta al gradino decade a zero indefinitamente, e viceversa.\n\nPer verificare la stabilità di un filtro lo si converte in formato *zero-pole-gain*, un formato che rappresenta il filtro come radici dei polinomi al numeratore della funzione di trasferimento (*zeroes*) e come radici del polinomio al denominatore (*poles*):\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# poles\n1/(polyroot(flt$a)) %>% zapsmall() %>% rev()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5913983+0.0000000i 0.7061996+0.3362227i 0.7061996-0.3362227i\n```\n\n\n:::\n\n```{.r .cell-code}\n# zeroes\n1/(polyroot(flt$b)) %>% zapsmall() %>% rev()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1+0i -1+0i -1+0i\n```\n\n\n:::\n:::\n\n\n\n\n\n\nMediante `gsignal` è più semplice convertire il filtro in formato `Zpg`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflt %>% as.Zpg()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$z\n[1] -1.0000016-2.850647e-06i -1.0000016+2.850647e-06i -0.9999967+0.000000e+00i\n\n$p\n[1] 0.5913984+0.0000000i 0.7061996-0.3362227i 0.7061996+0.3362227i\n\n$g\nNULL\n\nattr(,\"class\")\n[1] \"Zpg\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**Un filtro è stabile quando tutti i poli sono all'interno del cerchio unitario sul piano immaginario**: \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircle <- function(r=1, x0=0, y0=0, n=100, phi = 0) {\n  tibble(\n    i = 0:n,\n    theta = i * 2*pi / n,\n    x = x0 + r*cos(theta + phi),\n    y = y0 + r*sin(theta + phi)\n  )\n}\n\nflt %>% as.Zpg() %>% {\n  tibble(\n    zr = Re(.$z),\n    zi = Im(.$z),\n    pr = Re(.$p),\n    pi = Im(.$p)\n  )} %>% \n  ggplot() +\n  geom_point(aes(x=zr, y=zi), shape=21) +\n  geom_point(aes(x=pr, y=pi), shape=4) +\n  geom_path(data=circle(), aes(x=x, y=y), color=\"red\") +\n  coord_equal() +\n  labs(x=\"Real\", y=\"Imaginary\", title=\"Zero-Pole diagram\")\n```\n\n::: {.cell-output-display}\n![Grafico *zero-pole* per fil filtro IIR](filtri_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n# Filtri offline\n\nSe non è necessario applicare il filtro durante l'acquisizione ma si può farlo *ex-post*, è possibile ricorrere alla trasformata di Fourier. Il processo è il seguente:\n\n1. Si calcola la FFT del segnale (**senza applicare una finestra**)\n2. Si definisce una *funzione maschera* che, moltiplicata per lo spettro, riduca o annulli le bande di frequenza che si desidera attenuare\n3. si calcola la **trasformata inversa** della trasformata moltiplicata per la maschera.\n\nVediamo ad esempio il caso di un segnale ottenuto da un elettrocardiogramma, con frequenza di 256 Hz per una durata di 10 s, disponibile nel data frame `gsignal::signals`:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsignals %>% \n  mutate(\n    t = seq(0, 10, length.out=n()),\n  ) %>% \n  ggplot(aes(x=t, y=ecg)) +\n  geom_line() +\n  labs(color=\"segnale\", x=\"tempo (s)\", y=\"tensione (µV)\")\n```\n\n::: {.cell-output-display}\n![Segnale di elettrocardiogramma](filtri_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nOsserviamo il modulo della trasformata: decidiamo di filtrare le frequenze sopra 10 Hz.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsignals %>% \n  mutate(\n    i = (1:n())-1,\n    t = seq(0, 10, length.out=n()),\n    f = i / max(t),\n    fft = fft(ecg),\n    intensity = Mod(fft) / n() * 2\n  ) %>% \n  ggplot(aes(x=f)) +\n  geom_line(aes(y=intensity)) +\n  scale_x_continuous(minor_breaks = scales::minor_breaks_n(11)) +\n  labs(x=\"frequenza (Hz)\", y=\"tensione (µV)\")\n```\n\n::: {.cell-output-display}\n![FFT del segnale ECG](filtri_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nPer farlo definiamo una funzione filtro mediante una gaussiana `dnorm()` (anche se potremmo usare altre funzioni a piacere, a seconda del risultato desiderato). Si noti che la funzione maschera deve essere **simmetrica attorno alla frequenza di Nyquist** come lo è la trasformata.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwidth <- 8\noff <- 0\nsig <- signals %>% \n  mutate(\n    i = (1:n())-1,\n    t = seq(0, 10, length.out=n()),\n    f = i / max(t),\n    filter = \n      (dnorm(f, mean=off, sd=width) + dnorm(f, mean=max(f)-off, sd=width)) / \n      dnorm(0, mean=0, sd=width),\n    fft = fft(ecg),\n    fft_f = fft * filter,\n    intensity = Mod(fft) / n() * 2,\n    intensity_f = Mod(fft_f) / n() * 2,\n    phase = Arg(fft)/pi*180\n  ) \n\nsf <- 30\nsig %>% \n  ggplot(aes(x=f)) +\n  geom_line(aes(y=intensity)) +\n  geom_line(aes(y=filter*sf), color=\"red\") +\n  scale_x_continuous(minor_breaks = scales::minor_breaks_n(11)) +\n  scale_y_continuous(\n    sec.axis = sec_axis(~ . / sf, name = \"filter\")\n  )+\n  labs(x=\"frequenza (Hz)\", y=\"tensione (µV)\")\n```\n\n::: {.cell-output-display}\n![FFT del segnale ECG e funzione maschera (in rosso)](filtri_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nLa funzione maschera è stata riscalata in modo da valere 1 al suo massimo. Inoltre, l'ultimo grafico riporta la maschera sul secondo asse verticale, per leggibilità.\n\nLa trasformata moltiplicata per la maschera risulta:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsig %>% \n  ggplot(aes(x=f)) +\n  geom_line(aes(y=intensity_f)) +\n  geom_line(aes(y=filter*sf), color=\"red\") +\n  scale_x_continuous(minor_breaks = scales::minor_breaks_n(11)) +\n  scale_y_continuous(\n    sec.axis = sec_axis(~ . / sf, name = \"filter\")\n  )+\n  labs(x=\"frequenza (Hz)\", y=\"tensione (µV)\")\n```\n\n::: {.cell-output-display}\n![FFT del segnale ECG con applicata la funzione maschera](filtri_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nA questo punto possiamo anti-trasformare la trasformata mascherata, per ottenere il segnale filtrato e **privo di ritardo**:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsig %>% \n  mutate(\n    ecg_f = Re(ifft(fft_f))\n  ) %>% \n  select(t, ECG=ecg, `ECG (filt.)`=ecg_f) %>% \n  pivot_longer(-t) %>% \n  ggplot(aes(x=t)) + \n  geom_line(aes(y=value, color=name)) +\n  coord_cartesian(xlim=c(0,2), ylim=c(-200, 200)) +\n  labs(color=\"segnale\", x=\"tempo (s)\", y=\"tensione (µV)\")\n```\n\n::: {.cell-output-display}\n![Segnale ECG filtrato (dettaglio)](filtri_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\nSi noti che la anti-trasformata restituisce un segnale complesso, per cui è necessario scartare la parte immaginaria.\n\n**ESERCIZIO**: cambiare i valori di `off` e `width` per osservare come modificando la maschera cambia il segnale filtrato.\n\n\n# Taratura dinamica\n\n## Termocoppia\n\nConsideriamo il caso di una sonda PT100 immersa repentinamente in un bagno termostatato. La temperatura della sonda raggiunge quella del bagno secondo la legge:\n\n$$\nT(t) = (T_i - T_f)e^{-\\frac{t}{\\tau}} + T_f\n$$ {#eq-pt100}\n\n\n\n\n\n\n\n\n\n\n\n\n\nSappiamo che $T_i = 33.4$ °C, $T_f = 95$ °C e stimiamo che l'immersione inizi a $t_0 = 50$ s.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(temp, aes(x=t, y=T)) + \n  geom_line() +\n  geom_line(aes(y=Tn), color=\"red\", linewidth=1/3) +\n  labs(x=\"tempo (s)\", y=\"temperatura (°C)\")\n```\n\n::: {.cell-output-display}\n![Acquisizione con termocoppia PT100. In rosso la nominale](filtri_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n### Primo metodo: intercetta\n\nSecondo la @eq-pt100, a $t=\\tau$ si ha che $T(\\tau) = (T_i-T_f)e^{-1} + T_f$, cioè:\n\n\\begin{align}\nT_f - T(\\tau) &= (T_f - T_i)e^{-1} \\\\\n&= (95 - 33.4) \\cdot 0.368 \\\\\n&= 61.6 \\cdot 0.368 \\\\\n&=  22.661\n\\end{align}\n\ncioè $T(\\tau) = 72.339$ °C. In grafico:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTtau <- Tf - (Tf - Ti)*exp(-1)\n\nggplot(temp, aes(x=t, y=T)) + \n  geom_line() +\n  geom_hline(yintercept = Ttau, color=\"blue\") +\n  labs(x=\"tempo (s)\", y=\"temperatura (°C)\")\n```\n\n::: {.cell-output-display}\n![Identificazione della temperatura $T(\\tau)$](filtri_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n\n\n\nCioè risulta graficamente che $\\tau$ è la distanza tra l'inizio del transitorio e l'intersezione con la linea blu. Sui dati:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp %>% \n  select(t, T) %>%          # solo le colonne t e T\n  mutate(t = t - 50) %>%    # traslo i tempi all'inizio\n  dplyr::filter(T<Ttau) %>% # solo i valori < Ttau\n  slice_tail(n=1) %>%       # prendo solo l'ultima riga\n  knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n|    t|        T|\n|----:|--------:|\n| 34.5| 72.10326|\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n### Secondo metodo: linearizzazione\n\nLa @eq-pt100 può essere linearizzata così:\n\n\\begin{align}\n\\frac{T(t) -T_f}{T_i - T_f} &= e^{-\\frac{t}{\\tau}} \\\\\n\\ln\\left(\\frac{T(t) -T_f}{T_i - T_f}\\right) &= \\ln(e^{-\\frac{t}{\\tau}}) \\\\\n\\ln\\left(\\frac{T(t) -T_f}{T_i - T_f}\\right) &= -\\frac{t}{\\tau}\n\\end{align}\n\nPosso riorganizzare i dati come segue:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp.l <- temp %>% \n  select(t, T) %>% \n  mutate(t = t - 50) %>%\n  dplyr::filter(t>0 & t < 100) %>% \n  mutate(y = log((T-Tf)/(Ti - Tf))) %>% \n  dplyr::filter(!is.nan(y))\n\ntemp.lm <- temp.l %>% lm(y~t-1, data=.) \ntemp.lm %>% summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = y ~ t - 1, data = .)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.37869 -0.02358 -0.00112  0.02651  0.22497 \n\nCoefficients:\n    Estimate Std. Error t value Pr(>|t|)    \nt -2.986e-02  7.747e-05  -385.4   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.06302 on 198 degrees of freedom\nMultiple R-squared:  0.9987,\tAdjusted R-squared:  0.9987 \nF-statistic: 1.486e+05 on 1 and 198 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n\n```{.r .cell-code}\ntau <- round(-1/temp.lm$coefficients, 1)\ncat(paste(\"tau:\", tau))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntau: 33.5\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp.l %>% \n  ggplot(aes(x=t, y=y)) +\n  geom_smooth(method=\"lm\", formula = y~x-1) +\n  geom_point(size=0.5) +\n  labs(x=\"tempo (s)\", \n       y=latex2exp::TeX(\"$\\\\log_{10}(\\\\frac{T-T_f}{T_i-T_f})$ (T in °C)\"))\n```\n\n::: {.cell-output-display}\n![Regressione del modello dopo linearizzazione](filtri_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n### Terzo metodo: regressione non-lineare\n\nCon il terzo metodo si usa la regressione non-lineare ai minimi quadrati per ottenere direttamente tutti e tre i parametri $T_i, T_f, \\tau$:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemp.l <- temp %>% \n  select(t, T) %>% \n  mutate(t = t - 50) %>%\n  dplyr::filter(t>0) \n\nfit <- nls(T~(Ti - Tf)*exp(-t/tau) + Tf, \n    data = temp.l, \n    start = list(\n      Ti=30,\n      Tf=100,\n      tau=10\n    ))\n\nfit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNonlinear regression model\n  model: T ~ (Ti - Tf) * exp(-t/tau) + Tf\n   data: temp.l\n   Ti    Tf   tau \n33.44 95.06 33.60 \n residual sum-of-squares: 133.1\n\nNumber of iterations to convergence: 5 \nAchieved convergence tolerance: 5.435e-08\n```\n\n\n:::\n\n```{.r .cell-code}\ntemp.l %>% \n  modelr::add_predictions(fit, var=\"fit\") %>% \n  ggplot(aes(x=t, y=T)) + \n  geom_line() +\n  geom_line(aes(y=fit), color=\"red\", linewidth=1/4) +\n  labs(x=\"tempo (s)\", y=\"temperatura (°C)\")\n```\n\n::: {.cell-output-display}\n![](filtri_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\nSi notino i valori iniziali approssimativi passati per i tre parametri. \n\nI vantaggi di questo terzo metodo sono:\n\n* non è necessario stimare **soggettivamente** $T_i$ e $T_f$, ma vengono identificati direttamente dalla regressione\n* definendo il modello per parti (cioè costante per $t<t_i$), è possibile identificare anche $t_i$ (lo si lascia per esercizio)\n* mediante il metodo bootstrap è possibile ottenere gli intervalli di confidenza su tutti e tre i parametri (lo si lascia per esercizio)\n\nPer contro, è computazionalmente più complesso, mentre il primo e al limite anche il secondo metodo possono essere applicati anche \"a mano\".\n\n\n:::{.callout-note title=\"Esercizio\"}\nDefinire una funzione piecewise costante fino a $T_i$ e poi esponenziale e regredire tale funzione, identificando anche $T_i$\n:::\n\n## Considerazioni sulla relazione tra costante di tempo e funzione di trasferimento\n\n:::{.callout-important}\nMancano pagine 53-54.\n:::\n\n## Compensazione o misura dinamica\n\n:::{.callout-important}\nMancano pagine 55-58.\n:::\n\n\n# Determinazione Funzioni di Trasferimento mediante Parametri Concentrati ed Impedenze Generalizzate\n\n:::{.callout-important}\nMancano pagine 66-81, ma i due esempi originariamente in tabella sono qui riportati per esteso nel capitolo seguente.\n:::\n\n\n\n# Funzioni di trasferimento\n\nDi seguito, anziché utilizzare la funzione `gsignal::bodeplot()`, che usa la vecchia interfaccia per i grafici, utilizzeremo una funzione da noi definita, `ggbodeplot()`, basata su `ggplot2`. La definizione di questa funzione non è essenziale.\n\n<details>\n<summary>ggbodeplot function</summary>\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(control)\nlibrary(signal)\n\nggbodeplot <- function(tf, fmin=1, fmax=1e4, df=0.01) {\n  # vector of points for each order of magnitude (OOM):\n  pts <- 10^seq(0, 1, df) %>% tail(-1)\n  # vector of OOMs:\n  ooms <- 10^(floor(log10(fmin)):ceiling(log10(fmax)-1))\n  # combine pts and ooms:\n  freqs <- as.vector(pts %o% ooms)\n  # warning: bode wants pulsation!\n  bode(tf, freqs*2*pi) %>% {\n    tibble(f=.$w/(2*pi), `magnitude (dB)`=.$mag, `phase (deg)`=.$phase)} %>%\n    pivot_longer(-f) %>% \n    ggplot(aes(x=f, y=value)) +\n    geom_line() +\n    scale_x_log10(\n      minor_breaks=scales::minor_breaks_n(10), \n      labels= ~ latex2exp::TeX(paste0(\"$10^{\", log10(.), \"}$\"))) +\n    facet_wrap(~name, nrow=2, scales=\"free\") +\n    labs(x=\"frequency (Hz)\")\n}\n```\n:::\n\n\n\n\n\n</details>\n\n\n## Esempio: sistema per isolamento da vibrazioni. \n\nCon il metodo delle impedenze generalizzate si ottiene:\n\n$$\nH(i\\omega)=\\frac{V_\\mathrm{out}(i\\omega)}{V_\\mathrm{in}(i\\omega)}=\\frac{C i\\omega + K}{M (i\\omega)^2 + C i\\omega + K}\n$$ {#eq-tf}\n\nLa frequenza naturale del sistema è $f_0=\\frac{1}{2\\pi}\\sqrt{\\frac{K}{M}}$, e l'attenuazione comincia a $\\sqrt{2}f_0$.\n\nPossiamo definire la funzione di trasferimento in @eq-tf con la funzione `control::tf()`, che prende come due argomenti due vettori con i coefficienti della @eq-tf, in ordine decrescente di grado della variabile $i\\omega$:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- 10\nK <- 1000\nC <- 50\n\n# Frequenza naturale:\nf0 <- 1/(2*pi) * sqrt(K/M)\n\ntf(c(C, K),c(M, C, K)) %>% \n  ggbodeplot(fmin=0.1, fmax=100) +\n  geom_vline(xintercept=c(1, sqrt(2)) * f0, color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(f0, 2), \"Hz\", \n    \" - Isolation: >\", round(sqrt(2)*f0, 2), \"Hz\"))\n```\n\n::: {.cell-output-display}\n![Bode plot per il sistema di isolamento da vibrazioni](filtri_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n::: {.content-visible when-format=\"html\"}\n:::column-margin\n**Decibel** --- La magnitudine della funzione di trasferimento è espressa in decibel (dB). Un decibel corrisponde a $10 \\log_{10}(X)$. Tuttavia è d'uso scalare la magnitudine in modo che rappresenti il **rapporto tra le potenze**, che dipende dal quadrato della variabile in oggetto. Quindi l'effettiva relazione diventa $20 \\log_{10}(X)$. \n\nIn altre parole, un rapporto pari a 1:10 sulla variabile corrisponde a 1:100 sulla potenza; quindi se esprimo la magnitudine come $20 \\log_{10}(X)$ significa che un'attenuazione di -10 dB$_{20}$ sul segnale corrisponde a -10 dB$_{10}$ sulla potenza. Ancora più chiaramente: -20 dB sulla magnitudine significa un'attenuazione di 10 volte sul segnale, 100 volte sulla potenza.\n\n\n\n\n\n---\n:::\n:::\n\nSi noti che lo stesso risultato si ottiene a partire dalle equazioni della dinamica del sistema, effettuando la trasformata di Laplace $\\mathcal{L}$:\n\n\\begin{align}\nM\\ddot y + C\\dot y + Ky &= C\\dot x + K x \\\\\n&\\downarrow \\mathcal{L}\\left(\\frac{\\mathrm{d}^nx}{\\mathrm{d}t^n}\\right) = s^n X(s) \\\\\nM s^2 Y(s) + C s Y(s) + K Y(s) &= CsX(s) + KX(s)\n\\end{align} \n\ndalla quale otteniamo l'espressione per la funzione di trasferimento:\n\n$$\nH(s) = \\frac{Y(s)}{X(s)} = \\frac{Cs + K}{Ms^2 + Cs  + K }\n$$\nche corrisponde alla @eq-tf a meno della sostituzione $s=i\\omega$.\n\n\n## Esempio: accoppiamento rotativo motore-carico. \n\nCon il metodo delle impedenze generalizzate si ottiene:\n\n$$\nH(i\\omega) = \\frac{1}{I_c (i\\omega)^2 + Ci\\omega + K} = \\frac{1}{I_c/K (i\\omega)^2 + C/K i\\omega + 1}\n$$\n\nLa frequenza naturale può essere ottenuta con la funzione `control::damp()`, campo `omega`:\n\n::: {.cell}\n\n```{.r .cell-code}\nIc <-  10e-3\nK <-  5000\nC <-  1\n\nH <- tf(1,c(Ic/K, C/K, 1)) \nH.d <- damp(H, doPrint=FALSE)\n\nH %>% \n  ggbodeplot(fmin=10, fmax=1e4) +\n  geom_vline(xintercept=c(1, sqrt(2)) * H.d$omega[1]/(2*pi), color=\"red\", linetype=2) +\n  labs(title=paste(\n    \"Natural frequency:\", round(f0, 2), \"Hz\", \n    \" - Isolation: >\", round(sqrt(2)*f0, 2), \"Hz\"))\n```\n\n::: {.cell-output-display}\n![Bode plot per l'accoppiamento rotativo](filtri_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n\n",
    "supporting": [
      "filtri_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}