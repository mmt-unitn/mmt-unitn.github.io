{
  "hash": "59d2399c4243f695dea54c0b8cbba47f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R minimo\"\nauthor: \"Paolo Bosetti\"\ndate: \"2025-02-20\"\nformat: \n  html:\n    toc: TRUE\nengine: knitr\nwebr:\n  cell-options:\n    autorun: true\n    editor-font-scale: 0.9\n  packages: ['tidyverse']\nfilters:\n  - webr\n---\n\n\n\n\n# Basi del linguaggio\n\n:::{.callout-note}\nI blocchi di codice di seguito sono live: è possibile modificarli, eseguirli e osservare il risultato!\n:::\n\n## Variabili\n\nL'assegnazione di variabili avviene con il simbolo `<-`, il quale funziona anche in direzione opposta (`->`):\n\n```{webr-r}\na <- 10\n20 -> b\n```\n\n## Vettori\n\nI vettori si creano con la funzione `c()` (come **combine**):\n\n```{webr-r}\nv <- c(1, 2, 3, 4, 5)\n```\n\nLe sequenze regolari con passo 1 si creano con l'operatore `:`:\n\n```{webr-r}\nv.up <- 1:5\nv.down <- 5:1\n```\n\nSi noti che il punto per R è un carattere qualsiasi, quindi può fare parte di nomi di variabili.\n\nLe sequenze con passo diverso da 1 si ottengono con `seq()`:\n\n```{webr-r}\nv <- seq(1, 10, 0.1)\n```\n\nSe si vuole specificare il numero di elementi invece che il passo:\n\n```{webr-r}\nv <- seq(1, 10, length.out = 7)\nv\n```\n\n\n## Matrici\n\nUna matrice si crea con la funzione `matrix()`. Di default i valori vengono passati **per colonne**:\n\n```{webr-r}\nm <- matrix(1:12, nrow = 3)\nm\n```\nSi noti che le opzioni delle funzioni possono essere passate per posizione o per nome. Se si usa il nome, possono essere passate in qualsiasi posizione.\n\n```{webr-r}\nm <- matrix(byrow=TRUE, 1:12, nrow = 3)\nm\n```\n\n\n## Indicizzazione\n\nMatrici e vettori in R hanno **base 1**, cioè il primo elemento ha indice 1 (anziché 0 come in C/C++ e Python).\n\nPer **indicizzare** un vettore si usano le parentesi quadrate:\n\n```{webr-r}\nv.up[2]\n```\n\nPer una matrice si passano due argomenti tra le parentesi quadrate, omettendo uno o entrambi se si vile estrarre un'intera colonna o intera riga. Il primo argomento è quello di riga:\n\n```{webr-r}\nm[3,2]\nm[2,]\n```\n\nÈ possibile estrarre sottoinsiemi di elementi passando alle parentesi quadrate **vettori di indici**:\n\n```{webr-r}\nv.down[c(4,2)]\n```\n\nInfine, è possibile usare vettori di valori logici (`TRUE` o `FALSE`, abbreviabili in `T` e `F`). In questo caso, se il vettore di indici è più breve del vettore/matrice originale, si assume ripetuto:\n\n```{webr-r}\n# Vettore di indici lungo come v.up\nv.up[v.up > 2]\n# Vettore di indici più corto di v.up\nv.up[c(T,F)]\n```\n\n\n## Funzioni vettorializzate\n\nIn R ogni variabile è intrinsecamente un vettore e tutte (o quasi) le funzioni e operatori base sono **vettorializzate**, cioè operano elemento per elemento. Ciò spiega perché l'espressione `v.up[v.up > 2]` funziona: `v.up > 2` restituisce un vettore di valori logici lungo come `v.up`, valutando la diseguaglianza per ogni elemento di `v.up`.\n\n```{webr-r}\nv.up * 2\n```\n\nMa anche:\n\n```{webr-r}\nv.up + v.down\n```\n\nCiò fa sì che sia **raramente necessario utilizzare dei loop**.\n\n## Cicli e loop\n\nQuando proprio è necessario:\n\n```{webr-r}\ns <- 0\nfor (e in v.up) {\n  s <- s + e\n}\ns\n```\n\nanche se bastava (ed è molto più efficiente):\n\n```{webr-r}\nsum(v.up)\n```\n\n# Funzioni\n\nR è un **linguaggio funzionale**, cioè le funzioni sono *first class objects*, ossia tipi come gli altri e possono essere utilizzate anonime o assegnate a variabili:\n\n```{webr-r}\nmult <- function(x, factor = 2) x * factor\n\nmult(10)\n```\n\nSi noti che è possibile assegnare un *default* ad alcuni argomenti.\n\nAlcune funzioni (vedremo più avanti) accettano **funzioni come argomenti**. In tal caso è frequente usare l'abbreviazione (con `\\` al posto di `function`):\n\n```{webr-r}\nmult <- \\(x, factor = 1) x * factor\n```\n\n\n\n# Strutture dati\n\nLe principali strutture dati sono le **liste** e le **tabelle**:\n\n* **liste**: sono contenitori eterogenei, che possono cioè raggruppare valori di qualsiasi tipo. Possono essere **anonime**, nel qual caso gli elementi sono accessibili per posizione, oppure **nominate**, nel qual caso ogni elemento ha un nome univoco;\n* **tabelle**: sono matrici in cui le colonne hanno nomi. A differenza delle matrici, che sono sempre **omogenee**, le tabelle possono avere colonne di tipi diversi, ma ogni colonna deve essere internamente omogenea.\n\n## Liste\n\nLe liste si creano con la funzione `list()`:\n\n```{webr-r}\nl.anon <- list(2, \"sette\", 1:5)\nl.anon\n```\n\n```{webr-r}\nl.named <- list(\n  A = 1,\n  B = \"cinque\",\n  C = c(3,1,12.7),\n  ultimo = NA\n)\nl.named\n```\n\nSi noti che `NA` significa **not available** e rappresenta un elemento mancante.\n\nPer accedere agli elementi di una lista si usano sempre le parentesi quadrate:\n\n```{webr-r}\nl.anon[2]\nl.named[\"B\"]\n```\n\nSi noti però che usando `[]` si ottiene di nuovo una lista (una *sotto-lista*). Per ottenere l'elemento contenuto in una data posizione è necessario usare la doppia parentesi `[[]]`:\n\n```{webr-r}\nl.anon[[2]]\nl.named[[\"B\"]]\n```\n\n\n## Le tabelle\n\nLe tabelle sono la struttura più usata in R e si creano con la funzione `data.frame()`. Noi utilizzeremo però la funzione `tibble()`: una versione più evoluta che fa parte della famiglia di librerie `tidyverse`:\n\n```{webr-r}\n#| warning = FALSE\n# Prima carichiamo la libreria (una volta per sessione)\nlibrary(tidyverse)\n\nt1 <- tibble(\n  A = 1:5,\n  B = A ^ 2\n)\nt1\n```\n\nUna tabella può essere indicizzata per riga e per colonna come una matrice, ma è possibile anche attingere alle colonne come vettori usando **il nome**:\n\n```{webr-r}\nt1$A\n```\n\nE, ovviamente, per ottenere i numeri la cui radice è dispari:\n\n```{webr-r}\nt1$B[t1$A %% 2 == 1]\n```\n\n\n# La libreria `tidyverse`\n\nSi tratta di una libreria relativamente nuova che ha modificato radicalmente il modo di programmare in R, rendendolo più moderno ed efficiente. È in realtà una **meta-libreria** cioè un collezione di librerie, caricando la quale (comando `library()`) si caricano tutte le sotto librerie.\n\nSi noti che le librerie devono anzitutto essere installate: o con il comando `install.packages(\"tidyverse\")`, oppure da RStudio, pannello *Packages*, pulsante *Install.*\n\nUna volta installata, una libreria può essere utilizzata o *caricandola* con `library(nome_della_lib_senza_virgolette)`, oppure scrivendo il nome della libreria e doppio due punti prima della funzione, ad es. `dplyr::filter()`.\n\n\n## La gestione dei dati (*data mangling*)\n\nLa libreria `tidyverse` mette a disposizione tutto ciò che serve per maneggiare tabelle di dati in maniera molto completa, sintetica e efficiente.\n\nPer rendere il codice più leggibile, anziché nidificare le chiamate ad una serie di funzioni si preferisce utilizzare l'operatore **pipe**, `%>%`, che passa il risultato di una funzione come primo argomento della successiva:\n\n```{webr-r}\nseq(0, pi, pi/3) %>% round(digits=2)\n```\n\nche equivale a scrivere:\n\n```{webr-r}\nround(seq(0, pi, pi/3), digits=2)\n```\n\nma è più leggibile, soprattutto se si va a capo dopo ogni pipe, in modo che ad ogni riga corrisponda un passo dell'algoritmo. \n\n\nLe funzioni di *data mangling* più comuni sono:\n\n* `mutate()`, per **modificare** o aggiungere una o più colonne\n* `filter()`, per **filtrare** la tabella selezionando solo alcune righe\n* `select()`, per **selezionare** solo alcune colonne\n* `arrange()`, per **riordinare** le righe\n\nAd esempio:\n\n```{webr-r}\ntibble(\n  A = 1:10,\n  B = A ^ 2,\n  C = rnorm(length(A))\n) %>% \n  mutate(C = round(C, 3), D = LETTERS[A]) %>% \n  filter(A %% 2 == 0) %>% \n  select(D, B, C) %>% \n  arrange(desc(C))\n```\n\nSi noti che tutte queste funzioni sono **non distruttive**, cioè non alterano la tabella di partenza ma ne restituiscono una nuova. Se il risultato è utile per successive operazioni, quindi, è necessario salvarlo, ad esempio con:\n\n```{webr-r}\ntibble(\n  A = 1:10,\n  B = A ^ 2,\n  C = rnorm(length(A))\n) %>% \n  mutate(C = round(C, 3), D = LETTERS[A]) %>% \n  filter(A %% 2 == 0) %>% \n  select(D, B, C) -> t2\n```\n\nLe funzioni `group_by()` e `summarise()` servono per operare su **gruppi di righe**; ad esempio, per calcolare il massimo di `B` e la media di `C` per le righe in cui `A` è pari o dispari:\n\n```{webr-r}\ntibble(\n  A = 1:10,\n  B = A ^ 2,\n  C = rnorm(length(A))\n) %>% \n  mutate(even = A %% 2 == 0) %>% \n  group_by(even) %>%\n  summarise(B = max(B), C = mean(C))\n```\n\n\n## I grafici\n\n`tidyverse` ha messo a disposizione la libreria `ggplot2`, che consente di creare grafici **per layer**. Ogni layer rappresenta una geometria, ed è una funzione che comincia generalmente con `geom_`; i vari layer si sommano con un `+`. Il grafico comincia con `ggplot()`, che serve a caricare la tabella di dati e predisporre lo spazio del grafico stesso.\n\nLa funzione `aes()`infine rappresenta l'*estetica*, cioè stabilisce quali variabili (cioè colonne della tabella) vanno sui vari assi del grafico. Qui per *assi* si intendono sia gli assi cartesiani che gli assi generalizzati, cioè colori, dimensione, tipo linea, ecc. utilizzati per rappresentare le varie serie.\n\n```{webr-r}\nset.seed(0)\nt <- tibble(\n  A = 1:10,\n  B = A ^ 2,\n  C = rnorm(length(A))\n) \n\nt %>% \n  ggplot(aes(x=A, y=B)) +\n  geom_point(aes(color=C, size=C)) +\n  geom_line()\n```\n\nNel caso di più assi si passa l'estetica più generale a `ggplot()`, quelle particolari alle successive geometrie. In questo caso, solo per `geom_point()` si sono specificate le estetiche per coloer e dimensione del punto, entrambe collegate alla colonna `C`.\n\nSi noti che nelle estetiche è possibile anche applicare trasformazioni:\n\n```{webr-r}\nt %>% \n  ggplot(aes(x=A)) +\n  geom_point(aes(y=C*20+50)) +\n  geom_line(aes(y=B))\n```\n\nSerie differenti possono essere identificate per colore (o per tipo linea, o per larghezza linea, ecc.):\n\n```{webr-r}\nt %>% \n  mutate(C = C * 20 + 50) %>% \n  ggplot(aes(x=A)) +\n  geom_line(aes(y=C), color=\"red\") +\n  geom_line(aes(y=B), color=\"blue\")\n```\n\nIn questi casi però è preferibile usare l'**approccio *tidy* **: la tabella originale deve contenere una osservazione per riga, una variabile per colonna. La tabella `t` non è *tidy*, perché una stessa riga ha più di una osservazione (per `A`, `B` e `C`). \n\nPer rendere la tabella *tidy*:\n\n```{webr-r}\nt %>% \n  pivot_longer(-A, names_to = \"series\", values_to = \"value\")\n```\n\ndove `pivot_longer(-A, ...)` significa \"riorganizza tutte le colonne **meno** la colonna `A`\", dopodiché i nomi delle colonne vanno a finire nella colonna `series`, i valori nella colonna `value`.\n\nUna tabella tidy è più semplice da mettere in grafico (e più efficiente da manipolare):\n\n```{webr-r}\nt %>% \n  mutate(C = C * 20 + 50) %>% \n  pivot_longer(-A, names_to = \"series\", values_to = \"value\") %>% \n  ggplot(aes(x=A, y=value, color=series)) +\n  geom_line() +\n  labs(x=\"Indice\", y=\"Valore\", color=\"Serie\", title=\"Esempio tidy\")\n```\n\nCome si vede, si ottiene gratuitamente la legenda. Più serie possono essere separate contemporaneamente per colore, tipo di linea, larghezza di linea, trasparenza, ecc.\n\n\n# Map/reduce\n\nIn molti linguaggi moderni si sono diffusi gli algoritmi *map* e *reduce* come alternative efficienti (perché implementate a basso livello) dei loop espliciti. La prima realizza una **mappa**, cioè esegue la stessa operazione su tutti gli elementi di una collezione (tipicamente un vettore). La seconda **riduce** la dimensione di una collezione, ad esempio da un vettore a uno scalare, tipicamente accumulando gli elementi di una collezione.\n\nIn R, le operazioni analoghe sono fornite dal pacchetto `purrr`, parte di `tidyverse`.\n\n## *Map*\n\nle funzioni di `purrr` che cominciano con `map_*` operano su una lista o un vettore, ritornando una collezione di uguale dimensione e del tipo specificato. Ad esempio, `map_dbl()` restituisce una lista di double, `map_chr()` una lista di stringhe, ecc. Il primo argomento (spesso passato via pipe) è la collezione, il secondo è una funzione, eventualmente creata sul posto:\n\n```{webr-r}\n1:10 %>% \n  map_chr(function(x) LETTERS[x])\n```\n\nPer brevità si può scrivere anche:\n\n```{webr-r}\n1:10 %>% \n  map_chr(\\(x) LETTERS[x])\n```\n\ne addirittura, sostituendo `\\(x)` con `~` e `x` con `.`:\n\n```{webr-r}\n1:10 %>% map_chr(~ LETTERS[.])\n```\n\nTutti questi esempi in realtà possono essere evitati scrivendo semplicemente `LETERS[1:10]`, ma le funzioni `map_*()` risultano indispensabili quando non esiste una equivalente funzione vettorializzata.\n\n## *Reduce*\n\nL'algoritmo *reduce* applica una mappa alla collezione e accumula ogni elemento in un accumulatore. In R si ottiene mediante la funzione `purrr::reduce()`:\n\n```{webr-r}\n1:4 %>% reduce(\\(accu, elem) accu * elem)\n```\n\nPiù in breve:\n\n```{webr-r}\n1:4 %>% reduce(~ .x * .y)\n```\n\nIn questo caso, il valore iniziale dell'accumulatore è il primo elemento della collezione e il loop inizia a partire dal secondo. Quando invece l'accumulatore deve essere di un tipo differente dagli elementi, è necessario inizializzarlo con il parametro `.init`. È il caso, ad esempio, se voglio accumulare gli elementi in una lista:\n\n```{webr-r}\n0:4 %>% \n  reduce(\n    \\(accu, elem) {\n      accu[[ letters[elem + 1] ]] <- 2^elem\n      return(accu)\n    },\n    .init=list()\n  )\n```\n\nin cui l'accumulatore è inizialmente una lista vuota (`list()`) alla quale aggiungo di volta in volta 2 elevato a ogni elemento del vettore iniziale (`1:4`), con il nome pari alla *i*-esima lettera minuscola (con offset 1, `letters[elem + 1]`). A differenza degli esempi precedenti, questo non è semplificabile con una funzione vettorializzata.\n\n\n# File In/Out\n\nCi sono numerose funzioni per importare ed esportare dati su file, in differenti formati. Il metodo più semplice e comune è usando il formato CSV e le funzioni `read_csv()` e `write_csv()` (fornite da `tidyverse`).\n\nPer salvare una tabella su un file:\n\n```{webr-r}\ntibble(\n  A = 1:10,\n  B = rnorm(length(A)),\n  C = LETTERS[A]\n) %>% write_csv(file=\"example.csv\")\n```\n\nSe si usa il formato italiano/francese/spagnolo (celle separate da `;` e decimali separati da `,`), sostituire `write_csv()` con ` write_csv2()`.\n\nPer leggere un file:\n\n```{webr-r}\nread_csv(\"example.csv\")\n```\n\nAnalogamente, usare `read_csv2()` per il formato delle lingue romanze.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}